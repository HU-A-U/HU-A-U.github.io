<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Python之函数装饰器(一)"><meta name="keywords" content="python"><meta name="author" content="胡阿U"><meta name="copyright" content="胡阿U"><title>Python之函数装饰器(一) | Huzm Blog</title><link rel="shortcut icon" href="https://tva1.sinaimg.cn/large/006tNbRwly1gbdkxtnrvxj305k05kglh.jpg"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@latest/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#一等对象"><span class="toc-number">1.</span> <span class="toc-text">一等对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内部函数"><span class="toc-number">2.</span> <span class="toc-text">内部函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从函数中返回函数"><span class="toc-number">3.</span> <span class="toc-text">从函数中返回函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单装饰器"><span class="toc-number">4.</span> <span class="toc-text">简单装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#语法糖"><span class="toc-number">5.</span> <span class="toc-text">语法糖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#复用装饰器"><span class="toc-number">6.</span> <span class="toc-text">复用装饰器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#装饰器传参"><span class="toc-number">7.</span> <span class="toc-text">装饰器传参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从装饰器返回值"><span class="toc-number">8.</span> <span class="toc-text">从装饰器返回值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#你是谁"><span class="toc-number">9.</span> <span class="toc-text">你是谁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一些现实中使用的例子"><span class="toc-number">10.</span> <span class="toc-text">一些现实中使用的例子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#时间函数"><span class="toc-number">11.</span> <span class="toc-text">时间函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#调试代码"><span class="toc-number">12.</span> <span class="toc-text">调试代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#给代码降速"><span class="toc-number">13.</span> <span class="toc-text">给代码降速</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注册插件"><span class="toc-number">14.</span> <span class="toc-text">注册插件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#web应用中的权限验证"><span class="toc-number">15.</span> <span class="toc-text">web应用中的权限验证</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、在类上使用装饰器-装饰类"><span class="toc-number">15.1.</span> <span class="toc-text">1、在类上使用装饰器(装饰类)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、在一个函数上应用多个装饰器"><span class="toc-number">15.2.</span> <span class="toc-text">2、在一个函数上应用多个装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、带参数的装饰器"><span class="toc-number">15.3.</span> <span class="toc-text">3、带参数的装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、可以选择是否接收参数的装饰器"><span class="toc-number">15.4.</span> <span class="toc-text">4、可以选择是否接收参数的装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5、带状态的装饰器"><span class="toc-number">15.5.</span> <span class="toc-text">5、带状态的装饰器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6、类装饰器"><span class="toc-number">15.6.</span> <span class="toc-text">6、类装饰器</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbdl055vrpj308k090adk.jpg"></div><div class="author-info__name text-center">胡阿U</div><div class="author-info__description text-center">不以物喜 不以己悲</div><div class="follow-button"><a href="https://github.com/HU-A-U">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">13</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">11</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">5</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://tva1.sinaimg.cn/large/006tNbRwly1gbevpbjo1aj31c00u0qv5.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Huzm Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">首页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/categories">分类</a><a class="site-page" href="/404">公益404</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Python之函数装饰器(一)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-02-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/python/">python</a><span class="post-meta__separator">|</span><i class="fa fa-comment-o post-meta__icon" aria-hidden="true"></i><a href="/2020/02/03/Python函数装饰器/#disqus_thread"><span class="disqus-comment-count" data-disqus-identifier="2020/02/03/Python函数装饰器/"></span></a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>装饰器(Decorators)是python中最具特色且重要的一部分。</p>
<p>从功能上讲：装饰器的作用就是给已有的函数添加额外的功能，起到装饰的作用。</p>
<p>从定义上讲：装饰器就是一个函数，它接收一个函数作为参数并扩展这个函数的功能，但又不会去修改这个函数的内部，从而提高代码的复用性。</p>
<p>看一下装饰器长啥样(talk is cheap, show me the code)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个新的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorators</span><span class="params">(a_func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'I am doing some boring work before executing a_func()'</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        print(<span class="string">'I am doing some boring work after executing a_func()'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用装饰器装饰函数</span></span><br><span class="line"><span class="meta">@a_new_decorators</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的函数</span></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="string">I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="string">I am doing some boring work after executing a_func()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></p>
<p>下面通过代码的演变来理解装饰器的实现原理</p>
<h4 id="一等对象"><a href="#一等对象" class="headerlink" title="一等对象"></a>一等对象</h4><p>在python中，函数是一等对象，意思是函数可以作为参数被传递，就像其它的对象(string，int，float，list和其它)，思考下面的三个函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Hello <span class="subst">&#123;name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_awesome</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Yo <span class="subst">&#123;name&#125;</span>, together we are the awesomest!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_bob</span><span class="params">(greeter_func)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> greeter_func(<span class="string">"Bob"</span>)</span><br></pre></td></tr></table></figure></p>
<p>在这里,say_hello()和be_awsone()是常规函数，接收一个name参数返回一个字符串，然而greet_bob()函数，接收一个函数作为他的参数，我们可以将say_hello()或者be_awesome()函数传递给它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet_bob(say_hello)</span><br><span class="line"><span class="string">'Hello Bob'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet_bob(be_awesome)</span><br><span class="line"><span class="string">'Yo Bob, together we are the awesomest!'</span></span><br></pre></td></tr></table></figure></p>
<p>这里将函数名 say_hello 和 be_awsone 作为参数分别去调用函数greet_bob，但是并没有直接使用()，而是通过函数名引用函数，在greet_bob内部去通过()调用。</p>
<h4 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h4><p>在函数内部被定义的函数叫做内部函数，如下是内部函数的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Printing from the parent() function"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_child</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Printing from the first_child() function"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second_child</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Printing from the second_child() function"</span>)</span><br><span class="line"></span><br><span class="line">    second_child()</span><br><span class="line">    first_child()</span><br></pre></td></tr></table></figure></p>
<p>调用函数parent(),看一下输出的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parent()</span><br><span class="line">Printing <span class="keyword">from</span> the parent() function</span><br><span class="line">Printing <span class="keyword">from</span> the second_child() function</span><br><span class="line">Printing <span class="keyword">from</span> the first_child() function</span><br></pre></td></tr></table></figure></p>
<p>注意，内部函数的定义顺序无所谓，只会根据调用的顺序来按照顺序执行；<br>而且，内部函数在父函数被调用之前不会生效，他们的作用域在副函数的内部，只作为局部变量存在父函数的内部，直接调用内部函数 first_child(),你会得到如下错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'first_child'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p>
<p>不管什么时候调用函数parent(),内部函数都会被调用，因为他们的局部作用域，无法在父函数之外使用。</p>
<h4 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h4><p>在python中允许使用函数来作为返回值，如下是在函数parent中返回内部函数的函数名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_child</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi, I am Emma"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second_child</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Call me Liam"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> first_child</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> second_child</span><br></pre></td></tr></table></figure></p>
<p>注意，这里返回的是内部函数名，也就是对内部函数的引用，而带()是指对函数求值的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first = parent(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second = parent(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first</span><br><span class="line">&lt;function parent.&lt;locals&gt;.first_child at <span class="number">0x7f599f1e2e18</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second</span><br><span class="line">&lt;function parent.&lt;locals&gt;.second_child at <span class="number">0x7f599dad5268</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>由输出的结果可知：这个输出代表first变量引用了在parent()中的内部函数first_child()，second则指向了second_child()</p>
<p>现在就可以像常规函数一样使用first和second，虽然他们指向的函数无法被直接访问。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first()</span><br><span class="line"><span class="string">'Hi, I am Emma'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second()</span><br><span class="line"><span class="string">'Call me Liam'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Something is happening before the function is called.'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'Something is happening after the function is called.'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Whee！'</span>)</span><br><span class="line">    </span><br><span class="line">say_whee = my_decorator(say_whee)</span><br></pre></td></tr></table></figure>
<p>再直接调用say_whee的输出为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">Something <span class="keyword">is</span> happening before the function <span class="keyword">is</span> called.</span><br><span class="line">Whee!</span><br><span class="line">Something <span class="keyword">is</span> happening after the function <span class="keyword">is</span> called.</span><br></pre></td></tr></table></figure></p>
<p>可以看到装饰器的作用，只是简单调用了say_whee函数，却执行了额外的操作。</p>
<p>所谓的装饰器就发生在 say_whee = my_decorator(say_whee) 这一句。</p>
<p>事实上，say_whee 现在指向的是内部函数 wrapper,当在调用my_decorator(say_whee) 的时候将wrapper作为函数返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee</span><br><span class="line">&lt;function my_decorator.&lt;locals&gt;.wrapper at <span class="number">0x7f3c5dfd42f0</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>wrapper()引用原始的say_whee()函数内存地址赋值给了变量func，然后在两个print之间去调用它</p>
<p>简言之：装饰器包裹一个函数，并改变他的行为。</p>
<p>看下面一个例子，装饰器可以动态的来修改函数，所以我们定义一个函数只在白天执行，夜晚就不打扰您休息了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_during_the_night</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">7</span> &lt;= datetime.now().hour &lt; <span class="number">22</span>:</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span>  <span class="comment"># Hush, the neighbors are asleep</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Whee!"</span>)</span><br><span class="line"></span><br><span class="line">say_whee = not_during_the_night(say_whee)</span><br></pre></td></tr></table></figure></p>
<p>如果你在睡觉时间调用该函数不会发生任何事情，因为装饰器的作用就是让这个函数在白天执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>上面的装饰器say_whee()用起来有一点笨拙。首先，你键入了三次say_whee，另外，装饰器隐藏在了函数的定义之下作为替代，<br>python允许你使用@symbol的方式使用装饰器，有时被称为”pie”语法，下面的例子和之前第一个装饰器实现了同样的效果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Something is happening before the function is called."</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">"Something is happening after the function is called."</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Whee!"</span>)</span><br></pre></td></tr></table></figure></p>
<p>所以，@my_decorator 只是say_whee = my_decorator(say_whee)的一种快捷方式，这就是装饰器的用法</p>
<h4 id="复用装饰器"><a href="#复用装饰器" class="headerlink" title="复用装饰器"></a>复用装饰器</h4><p>下面创建了一个decorator.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p>
<p>再在另外一个py文件中导入这个复用装饰器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Whee!'</span>)</span><br></pre></td></tr></table></figure></p>
<p>最后运行这个例子，你会发现 say_whee()函数执行了两次<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">Whee!</span><br><span class="line">Whee!</span><br></pre></td></tr></table></figure></p>
<h4 id="装饰器传参"><a href="#装饰器传参" class="headerlink" title="装饰器传参"></a>装饰器传参</h4><p>当被装饰的函数需要需要传入参数，这时函数还能正常运行吗？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello &#123;&#125;'</span>.format(name))</span><br></pre></td></tr></table></figure></p>
<p>报错了，预料之中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet(<span class="string">"World"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: wrapper_do_twice() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure></p>
<p>原因在于，装饰器内部函数wrapper_do_twice()定义的时候并没有接收参数，你可以重新定义wrapper_do_twice()函数来接收一个参数，但是前面被装饰的函数say_whee()就会报错，<br>因为它并不需要传递一个参数。</p>
<p>所以装饰器的传参，是在内部函数中使用 *args 和 **kwargs,它可以接受任意个的关键字参数，然后来修改decorator.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p>
<p>此bug已修复<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">Whee!</span><br><span class="line">Whee!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet(<span class="string">"World"</span>)</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p>
<h4 id="从装饰器返回值"><a href="#从装饰器返回值" class="headerlink" title="从装饰器返回值"></a>从装饰器返回值</h4><p>被装饰的函数返回值会发生什么？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Creating greeting!'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello &#123;&#125;'</span>.format(name)</span><br></pre></td></tr></table></figure></p>
<p>运行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hi_adam = return_greeting(<span class="string">"Adam"</span>)</span><br><span class="line">Creating greeting</span><br><span class="line">Creating greeting</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hi_adam)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure></p>
<p>发现函数的返回值被装饰器吃了</p>
<p>因为装饰器的内部函数do_twice_wrapper()没有返回值，故返回为None。</p>
<p>所以我们要在内部函数中返回被装饰的函数的返回值，修改decorator.py如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p>
<p>再次调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>return_greeting(<span class="string">"Adam"</span>)</span><br><span class="line">Creating greeting</span><br><span class="line">Creating greeting</span><br><span class="line"><span class="string">'Hi Adam'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="你是谁"><a href="#你是谁" class="headerlink" title="你是谁"></a>你是谁</h4><p>在使用Python(尤其是在交互式shell中)时，强大的内省是非常方便的功能。内省是对象在运行时了解其自身属性的能力。例如，函数知道自己的名称和文档:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="keyword">print</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span>.__name__</span><br><span class="line"><span class="string">'print'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(<span class="keyword">print</span>)</span><br><span class="line">Help on built-<span class="keyword">in</span> function <span class="keyword">print</span> <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">print(...)</span><br><span class="line">    &lt;full help message&gt;</span><br></pre></td></tr></table></figure></p>
<p>内省同样适用于你自定义的函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee</span><br><span class="line">&lt;function do_twice.&lt;locals&gt;.wrapper_do_twice at <span class="number">0x7f43700e52f0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee.__name__</span><br><span class="line"><span class="string">'wrapper_do_twice'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(say_whee)</span><br><span class="line">Help on function wrapper_do_twice <span class="keyword">in</span> module decorators:</span><br><span class="line"></span><br><span class="line">wrapper_do_twice()</span><br></pre></td></tr></table></figure></p>
<p>然而say_whee()函数却显示为装饰器内部函数do_twice_wrapper()</p>
<p>为了修复这个，装饰器需要使用@functools.wraps装饰器，它会保留原始函数的信息，再次更新下decorators.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p>
<p>不需要对函数say_whee()做任何修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee</span><br><span class="line">&lt;function say_whee at <span class="number">0x7ff79a60f2f0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee.__name__</span><br><span class="line"><span class="string">'say_whee'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(say_whee)</span><br><span class="line">Help on function say_whee <span class="keyword">in</span> module whee:</span><br><span class="line"></span><br><span class="line">say_whee()</span><br></pre></td></tr></table></figure></p>
<p>技术细节:@funtools.wraps 装饰器使用函数functools.update_wrapper()来更新指定的属性，像<strong>name</strong>和<strong>doc</strong>来用于自省</p>
<h4 id="一些现实中使用的例子"><a href="#一些现实中使用的例子" class="headerlink" title="一些现实中使用的例子"></a>一些现实中使用的例子</h4><p>我们来看一些用处更大的装饰器例子。你会注意到他们主要的模式和你现在所学的都是一样的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_decorator</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Do something before</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># Do something after</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper_decorator</span><br></pre></td></tr></table></figure>
<p>对于构建更复杂的函数这是一个很好的模版</p>
<h4 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h4><p>@timer 装饰器，他会测量函数的运行时间，并且打印持续时间到控制台，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Print the runtime of the decorated function"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_timer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.perf_counter()    <span class="comment"># 1</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        end_time = time.perf_counter()      <span class="comment"># 2</span></span><br><span class="line">        run_time = end_time - start_time    <span class="comment"># 3</span></span><br><span class="line">        print(<span class="string">f"Finished <span class="subst">&#123;func.__name__&#125;</span> in <span class="subst">&#123;run_time:<span class="number">.4</span>f&#125;</span> secs"</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper_timer</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waste_some_time</span><span class="params">(num_times)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_times):</span><br><span class="line">        sum([i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>)])</span><br></pre></td></tr></table></figure></p>
<p>这个装饰器在函数运行之前获取时间，在函数执行完之后又获取了一次时间，最后做差求得执行时间，使用time.perf_counter()函数，可以很精准的计算时间间隔，执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>waste_some_time(<span class="number">1</span>)</span><br><span class="line">Finished <span class="string">'waste_some_time'</span> <span class="keyword">in</span> <span class="number">0.0010</span> secs</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>waste_some_time(<span class="number">999</span>)</span><br><span class="line">Finished <span class="string">'waste_some_time'</span> <span class="keyword">in</span> <span class="number">0.3260</span> secs</span><br></pre></td></tr></table></figure></p>
<h4 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h4><p>下面的@debug装饰器会在每次被调用的时候打印函数传入的参数和执行返回的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Print the function signature and return value"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_debug</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        args_repr = [repr(a) <span class="keyword">for</span> a <span class="keyword">in</span> args]                      <span class="comment"># 将args创建为列表，使用repr修饰</span></span><br><span class="line">        kwargs_repr = [<span class="string">f"<span class="subst">&#123;k&#125;</span>=<span class="subst">&#123;v!r&#125;</span>"</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items()]  <span class="comment"># 将kwargs创建为列表，使用f-string格式化参数为key=value，!r表示使用repr()表示值</span></span><br><span class="line">        signature = <span class="string">", "</span>.join(args_repr + kwargs_repr)           <span class="comment"># args和kwargs转换后会合并在signature变量中，使用逗号分隔每个变量</span></span><br><span class="line">        print(<span class="string">f"Calling <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;signature&#125;</span>)"</span>)</span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;func.__name__!r&#125;</span> returned <span class="subst">&#123;value!r&#125;</span>"</span>)           <span class="comment"># 函数运行结束后会返回值</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper_debug</span><br></pre></td></tr></table></figure></p>
<p>下面来测试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_greeting</span><span class="params">(name, age=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> age <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Howdy <span class="subst">&#123;name&#125;</span>!"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Whoa <span class="subst">&#123;name&#125;</span>! <span class="subst">&#123;age&#125;</span> already, you are growing up!"</span></span><br></pre></td></tr></table></figure></p>
<p>注意@debug装饰器如何打印make_greeting()函数的signature 和返回值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_greeting(<span class="string">"Benjamin"</span>)</span><br><span class="line">Calling make_greeting(<span class="string">'Benjamin'</span>)</span><br><span class="line"><span class="string">'make_greeting'</span> returned <span class="string">'Howdy Benjamin!'</span></span><br><span class="line"><span class="string">'Howdy Benjamin!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_greeting(<span class="string">"Richard"</span>, age=<span class="number">112</span>)</span><br><span class="line">Calling make_greeting(<span class="string">'Richard'</span>, age=<span class="number">112</span>)</span><br><span class="line"><span class="string">'make_greeting'</span> returned <span class="string">'Whoa Richard! 112 already, you are growing up!'</span></span><br><span class="line"><span class="string">'Whoa Richard! 112 already, you are growing up!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_greeting(name=<span class="string">"Dorrisile"</span>, age=<span class="number">116</span>)</span><br><span class="line">Calling make_greeting(name=<span class="string">'Dorrisile'</span>, age=<span class="number">116</span>)</span><br><span class="line"><span class="string">'make_greeting'</span> returned <span class="string">'Whoa Dorrisile! 116 already, you are growing up!'</span></span><br><span class="line"><span class="string">'Whoa Dorrisile! 116 already, you are growing up!'</span></span><br></pre></td></tr></table></figure>
<h4 id="给代码降速"><a href="#给代码降速" class="headerlink" title="给代码降速"></a>给代码降速</h4><p>场景如下，对一个检查资源是否存在的函数进行速度限制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_down</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Sleep 1 second before calling the function"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_slow_down</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_slow_down</span><br><span class="line"></span><br><span class="line"><span class="meta">@slow_down</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(from_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> from_number &lt; <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"Liftoff!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(from_number)</span><br><span class="line">        countdown(from_number - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p>
<p>countdown()函数是一个递归函数,执行如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Liftoff!</span><br></pre></td></tr></table></figure></p>
<h4 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h4><p>可以利用装饰器的原理，将函数注册到一个字典里，但不对函数做额外的操作，将其解包后返回，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">PLUGINS = dict()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Register a function as a plug-in"""</span></span><br><span class="line">    PLUGINS[func.__name__] = func</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Hello <span class="subst">&#123;name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_awesome</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Yo <span class="subst">&#123;name&#125;</span>, together we are the awesomest!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomly_greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    greeter, greeter_func = random.choice(list(PLUGINS.items()))</span><br><span class="line">    print(<span class="string">f"Using <span class="subst">&#123;greeter!r&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> greeter_func(name)</span><br></pre></td></tr></table></figure></p>
<p>@register装饰器只是在全局PLUGINS 字典中储存了被装饰函数的引用。</p>
<p>注意你不需要在例子中写内部函数或者使用@functools.wraps ，因为返回的是一个未经过修改的初始函数。</p>
<p>randomly_greet()函数在注册函数中随机选择一个使用。注意PLUGINS字典已经包含了对注册为插件的每个函数对象的引用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PLUGINS</span><br><span class="line">&#123;<span class="string">'say_hello'</span>: &lt;function say_hello at <span class="number">0x7f768eae6730</span>&gt;,</span><br><span class="line"> <span class="string">'be_awesome'</span>: &lt;function be_awesome at <span class="number">0x7f768eae67b8</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>randomly_greet(<span class="string">"Alice"</span>)</span><br><span class="line">Using <span class="string">'say_hello'</span></span><br><span class="line"><span class="string">'Hello Alice'</span></span><br></pre></td></tr></table></figure></p>
<p>这个插件的主要用处在于不需要再单独维护一个插件列表。这个列表在插件注册时自动创建，使得添加一个新插件变得很简单，只需定义函数并用@register装饰即可。</p>
<p>如果你对python中的globals()函数熟悉，你可能会看到一些和我们的插件结构相似之处。globals()可以访问当前作用于的所有全局变量<br>包括我们的插件:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()</span><br><span class="line">&#123;..., <span class="comment"># Lots of variables not shown here.</span></span><br><span class="line"> <span class="string">'say_hello'</span>: &lt;function say_hello at <span class="number">0x7f768eae6730</span>&gt;,</span><br><span class="line"> <span class="string">'be_awesome'</span>: &lt;function be_awesome at <span class="number">0x7f768eae67b8</span>&gt;,</span><br><span class="line"> <span class="string">'randomly_greet'</span>: &lt;function randomly_greet at <span class="number">0x7f768eae6840</span>&gt;&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用@register 装饰器还可以创建感兴趣的变量管理列表，有效地从globals()中筛选出一些函数</p>
<h4 id="web应用中的权限验证"><a href="#web应用中的权限验证" class="headerlink" title="web应用中的权限验证"></a>web应用中的权限验证</h4><p>我们在web应用中一些有权限的页面只能在用户登录之后才能被访问，可以给该页面的路由函数使用权限验证的装饰器，来进行登陆权限的校验，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, g, request, redirect, url_for</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Make sure user is logged in before proceeding"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_login_required</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> g.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">"login"</span>, next=request.url))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_login_required</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/secret")</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>上面的内容就是flask框架中，使用装饰器实现权限验证的操作。</p>
<p>以上就是介绍的如何创建简单的装饰器，并且非常了解什么是装饰器以及它们是如何工作的。</p>
<p>在下一篇中回去研究一下装饰器的一些高级用法：</p>
<h5 id="1、在类上使用装饰器-装饰类"><a href="#1、在类上使用装饰器-装饰类" class="headerlink" title="1、在类上使用装饰器(装饰类)"></a>1、在类上使用装饰器(装饰类)</h5><h5 id="2、在一个函数上应用多个装饰器"><a href="#2、在一个函数上应用多个装饰器" class="headerlink" title="2、在一个函数上应用多个装饰器"></a>2、在一个函数上应用多个装饰器</h5><h5 id="3、带参数的装饰器"><a href="#3、带参数的装饰器" class="headerlink" title="3、带参数的装饰器"></a>3、带参数的装饰器</h5><h5 id="4、可以选择是否接收参数的装饰器"><a href="#4、可以选择是否接收参数的装饰器" class="headerlink" title="4、可以选择是否接收参数的装饰器"></a>4、可以选择是否接收参数的装饰器</h5><h5 id="5、带状态的装饰器"><a href="#5、带状态的装饰器" class="headerlink" title="5、带状态的装饰器"></a>5、带状态的装饰器</h5><h5 id="6、类装饰器"><a href="#6、类装饰器" class="headerlink" title="6、类装饰器"></a>6、类装饰器</h5></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">胡阿U</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hu-a-u.com/2020/02/03/Python函数装饰器/">https://hu-a-u.com/2020/02/03/Python函数装饰器/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hu-a-u.com">Huzm Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/wechatpay.png"><div class="post-qr-code__desc">微信打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/images/alipay.png"><div class="post-qr-code__desc">支付宝打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/02/04/Python之函数装饰器-二/"><i class="fa fa-chevron-left">  </i><span>Python之函数装饰器(二)</span></a></div><div class="next-post pull-right"><a href="/2020/02/01/python之上下文管理器/"><span>python之上下文管理器</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="disqus_thread"></div><script>var unused = null;
var disqus_config = function () {
  this.page.url = 'https://hu-a-u.com/2020/02/03/Python函数装饰器/';
  this.page.identifier = '2020/02/03/Python函数装饰器/';
  this.page.title = 'Python之函数装饰器(一)';
}
var d = document, s = d.createElement('script');
s.src = "https://" + 'huzm' +".disqus.com/embed.js";
s.setAttribute('data-timestamp', '' + +new Date());
(d.head || d.body).appendChild(s);</script><script id="dsq-count-scr" src="https://huzm.disqus.com/count.js" async></script></div></div><footer class="footer-bg" style="background-image: url(https://tva1.sinaimg.cn/large/006tNbRwly1gbevpbjo1aj31c00u0qv5.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2020 By 胡阿U</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hu-a-u.com">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o">总阅读量</i><span id="busuanzi_value_page_pv"></span><span>次</span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>