<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Flask-蓝图(Blueprint)</title>
      <link href="/2020/02/24/Flask-%E8%93%9D%E5%9B%BE-Blueprint/"/>
      <url>/2020/02/24/Flask-%E8%93%9D%E5%9B%BE-Blueprint/</url>
      
        <content type="html"><![CDATA[<h3 id="一、蓝图的使用场景"><a href="#一、蓝图的使用场景" class="headerlink" title="一、蓝图的使用场景"></a>一、蓝图的使用场景</h3><p>在最初期使用flask框架的时候，是从单个文件开始的，在这单个文件中可以定义flask核心对象app，路由，视图函数，模型等等。<br>但随着业务的慢慢发展，不同的业务都放在单个文件中，会变得非常复杂，难以阅读维护。</p><p>如下例子：我们在一个文件中写入多个路由，看起来十分的混乱<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/detail')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'detail'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route('/admin_home')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admin_home</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'admin_home'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route('/new')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'new'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/delete')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'delete'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></p><p><strong>问题：一个执行文件中，功能代码过多</strong>。这种情况下需要将代码模块化。根据功能分成不同的模块，降低代码的耦合度。python中的模块制作和导入功能就是基于实现功能模块的封装的需求。</p><p><strong>尝试使用模块导入的方法解决</strong>：我们把上述的一个py文件的多个路由视图函数给拆分成两个文件：app.py和admin.py文件。app.py文件作为程序启动文件，创建了flask核心对象app；因为在admin.py中需要将路由、视图函数注册到flask的核心对象app上，所以需要将app.py文件中的app对象导入到admin.py中。</p><ul><li><p>文件app.py放入app核心应用，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入admin中的内容</span></span><br><span class="line"><span class="keyword">from</span> admin <span class="keyword">import</span> admin_home, new, delete</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/index')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'index'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/detail')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'detail'</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure></li><li><p>admin.py编写其他视图函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> app <span class="keyword">import</span> app</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/admin_home')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admin_home</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'admin_home'</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">@app.route('/new')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'new'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/delete')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">()</span>:</span></span><br><span class="line">   <span class="keyword">return</span> <span class="string">'delete'</span></span><br></pre></td></tr></table></figure></li><li><p>在app.py启动flask，发现报错如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Error: While importing &quot;flask_example.app&quot;, an ImportError was raised:</span><br><span class="line"></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;F:\pythonProject\flask_example\venv\lib\site-packages\flask\cli.py&quot;, line 240, in locate_app</span><br><span class="line">    __import__(module_name)</span><br><span class="line">  File &quot;F:\pythonProject\flask_example\app.py&quot;, line 4, in &lt;module&gt;</span><br><span class="line">    from .admin import admin_home, new, edit</span><br><span class="line">  File &quot;F:\pythonProject\flask_example\admin.py&quot;, line 1, in &lt;module&gt;</span><br><span class="line">    from .app import app</span><br><span class="line">ImportError: cannot import name &apos;app&apos; from &apos;flask_example.app&apos; (F:\pythonProject\flask_example\app.py)</span><br></pre></td></tr></table></figure></li></ul><p>由于连个文件之间互相引用，造成循环引用。</p><h3 id="二、什么是蓝图-Blueprint？"><a href="#二、什么是蓝图-Blueprint？" class="headerlink" title="二、什么是蓝图 Blueprint？"></a>二、什么是蓝图 Blueprint？</h3><p>简单来说，蓝图是一个存储操作方法的容器，存储的是路由和视图函数映射的集合，将这个蓝图对象注册到flask核心对象app之后就可以被调用。在Flask中可以通过蓝图组织URL来处理请求。</p><p>Flask使用蓝图让应用功能实现模块化，且有如下属性：</p><ul><li>一个flask核心对象可以具有多个Blueprint对象</li><li>可以将一个Blueprint注册到任何一个未使用的URL下比如”/“</li><li>Blueprint可以单独具有自己的模版、静态文件或者其他的通用的操作方法，他并不是必须要实现应用的视图和函数</li><li>在一个flask核心对象初始化的时候，就应该注册所需要使用的Blueprint</li></ul><p>但是一个蓝图不是一个独立的应用，他不能够独自的运行，而必须要注册到某一个应用中。</p><h3 id="三、蓝图的简单使用"><a href="#三、蓝图的简单使用" class="headerlink" title="三、蓝图的简单使用"></a>三、蓝图的简单使用</h3><p>蓝图对象的使用和flask的核心对象的使用很类似，最大的区别在于一个蓝图对象无法独立运行，必须将它注册到一个应用对象上才能使用。</p><p>使用蓝图可以大致分为下面三个步骤</p><ul><li><p>1.创建一个蓝图对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin = Blueprint(<span class="string">'admin'</span>,__name__)</span><br></pre></td></tr></table></figure></li><li><p>2.将路由视图函数注册到创建的蓝图对象上，指定静态文件夹，注册模版过滤器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@admin.route('/admin_home')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">admin_home</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'admin_home'</span></span><br></pre></td></tr></table></figure></li><li><p>3.在应用对象上注册这个蓝图对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.register_blueprint(admin,url_prefix=<span class="string">'admin'</span>)</span><br></pre></td></tr></table></figure></li></ul><p>当这个应用启动之后，通过/admin/admin_home可以访问到蓝图中定义的视图函数</p><h3 id="四、运行机制"><a href="#四、运行机制" class="headerlink" title="四、运行机制"></a>四、运行机制</h3><ul><li>蓝图是保存了一组将来可以在应用对象上执行的操作，注册路由就是一种操作。</li><li>当在应用上调用用route装饰器注册路由时，这个操作将修改对象的url_map路由表。</li><li>然而，蓝图对象根本没有路由表，当我们在蓝图对象上调用route装饰器注册路由时，他只是在内部的一个延时操作记录列表defered_functions中添加了一个项。</li><li>当执行应用对象的register_blueprint() 方法时，应用对象将从蓝图对象的defered_functions列表中取出每一项，并以自身作为参数执行该匿名函数，即调用应用对象的add_url_rule()方法，这将是真正的修改应用对象的路由列表。</li></ul><h3 id="五、蓝图的url前缀"><a href="#五、蓝图的url前缀" class="headerlink" title="五、蓝图的url前缀"></a>五、蓝图的url前缀</h3><ul><li>当我们在应用对象上注册一个蓝图时，可以指定一个url_prefix关键字参数（这个参数默认是 /）；也可以在创建蓝图对象的时候指定。</li><li>在应用最终的路由表url_map中，在蓝图上注册的路由URL自动被加上了这个前缀，这个可以保证在多个蓝图中使用相同的URL规则而不会最终引起冲突，只要在注册蓝图时将不同的蓝图挂接到不同的路径即可。</li><li>在用url_for()反解析蓝图管理的路由时，方法中需要指定蓝图的名字，即：url_for(‘蓝图的第一个参数.视图函数’, 参数)==&gt;url_for(‘admin.admin_home’,参数)。</li></ul><h3 id="六、蓝图管理静态路由和模版"><a href="#六、蓝图管理静态路由和模版" class="headerlink" title="六、蓝图管理静态路由和模版"></a>六、蓝图管理静态路由和模版</h3><h4 id="注册静态路由"><a href="#注册静态路由" class="headerlink" title="注册静态路由"></a><strong><em>注册静态路由</em></strong></h4><p>若要使用蓝图对象管理自己的静态目录的路由。需要我们在创建时指定 static_folder和template_folder 参数。</p><p>如下就是将蓝图所在文件夹下的admin_static目录设置为静态目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">admin = Blueprint(<span class="string">'admin'</span>,__name__,static_folder=<span class="string">'admin_static'</span>)</span><br><span class="line">app.register_blueprint(admin,url_prefix=<span class="string">'admin'</span>)</span><br></pre></td></tr></table></figure></p><p>这样定义完之后就可以使用/admin/admin_static 访问admin_static目录下的静态文件，还可以使用static_url_path来改变静态目录的路由。</p><p>如下，将admin_static文件夹的路由设置为 /lib。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin = Blueprint(<span class="string">'admin'</span>,__name__,static_folder=<span class="string">'admin_static'</span>,static_url_path=<span class="string">'/lib'</span>)</span><br></pre></td></tr></table></figure></p><h4 id="设置模版目录"><a href="#设置模版目录" class="headerlink" title="设置模版目录"></a><strong><em>设置模版目录</em></strong></h4><p>蓝图对象默认的模板目录为系统的模版目录，可以在创建蓝图对象时使用 template_folder 关键字参数设置蓝图的模板目录<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin = Blueprint(<span class="string">'admin'</span>,__name__,template_folder=<span class="string">'admin_templates'</span>)</span><br></pre></td></tr></table></figure></p><p>注：如果在 templates 中存在和 my_templates 同名文件,则系统会优先使用 templates 中的文件。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pythoy中字符串逆序的几种方法</title>
      <link href="/2020/02/07/Pythoy%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
      <url>/2020/02/07/Pythoy%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8F%8D%E8%BD%AC%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="第一种：字符串切片"><a href="#第一种：字符串切片" class="headerlink" title="第一种：字符串切片"></a>第一种：字符串切片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"hello"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[::<span class="number">-1</span>]</span><br><span class="line"><span class="string">'olleh'</span></span><br></pre></td></tr></table></figure><h3 id="第二种：列表的reverse-或sort-方法"><a href="#第二种：列表的reverse-或sort-方法" class="headerlink" title="第二种：列表的reverse()或sort()方法"></a>第二种：列表的reverse()或sort()方法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'abcd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li.reverse()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(li)</span><br><span class="line"><span class="string">'dcba'</span></span><br></pre></td></tr></table></figure><p>此处注意，reverse()方法没有返回值，故 “”.join(li.reverse())的写法肯定会报错。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'abcd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li.sort(reverse=<span class="literal">True</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(li)</span><br><span class="line"><span class="string">'dcba'</span></span><br></pre></td></tr></table></figure></p><p>sort方法是将列表内的元素按照一定顺序进行排列，默认为从小到大，参数reverse=True可改为由大到小，逆序排列。<br></p><p>或者将列表切片反转<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'abcd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(li[::<span class="number">-1</span>])</span><br><span class="line"><span class="string">'dcba'</span></span><br></pre></td></tr></table></figure></p><h3 id="第三种：使用reduce"><a href="#第三种：使用reduce" class="headerlink" title="第三种：使用reduce()"></a>第三种：使用reduce()</h3><p>在python2中可直接使用reduce函数，在python3中需在functools库里导入。</p><p>reduce函数语法：</p><p>reduce(function, iterable[, initializer])　　</p><ul><li><p>function–函数，有两个参数　　</p></li><li><p>iterable–可迭代对象　　</p></li><li><p>initializer–可选，初始参数</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x,y)</span>:</span></span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span> x + y</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'abcd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x,y:y+x,name)</span><br><span class="line"><span class="string">'dcba'</span></span><br></pre></td></tr></table></figure><h3 id="第四种：使用-python3-内置函数-reversed-函数"><a href="#第四种：使用-python3-内置函数-reversed-函数" class="headerlink" title="第四种：使用 python3 内置函数 reversed()函数"></a>第四种：使用 python3 内置函数 reversed()函数</h3><p>reversed函数返回一个反转的迭代器。</p><p>reversed语法：</p><ul><li><p>reversed(seq)　　</p></li><li><p>seq–要转换的序列，可以是 tuple, string, list 或 range。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'1234'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reversed(name)</span><br><span class="line">&lt;reversed object at <span class="number">0x1096f9668</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">""</span>.join(list(reversed(name)))</span><br><span class="line"><span class="string">'4321'</span></span><br></pre></td></tr></table></figure><h3 id="第五种：使用递归"><a href="#第五种：使用递归" class="headerlink" title="第五种：使用递归"></a>第五种：使用递归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"abcd"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> len(name) &lt; <span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> name</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> func(name[<span class="number">1</span>:]) + name[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>func(name)</span><br><span class="line"><span class="string">'dcba'</span></span><br></pre></td></tr></table></figure><h3 id="第六种：使用栈"><a href="#第六种：使用栈" class="headerlink" title="第六种：使用栈"></a>第六种：使用栈</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">'abcd'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>li = list(name) <span class="comment"># 模拟全部入栈</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = <span class="string">""</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span>(len(li) &gt; <span class="number">0</span>):</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>    res += li.pop() <span class="comment"># 模拟出栈</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="string">'dcba'</span></span><br></pre></td></tr></table></figure><h3 id="第七种：for循环"><a href="#第七种：for循环" class="headerlink" title="第七种：for循环"></a>第七种：for循环</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    max_index = len(name)<span class="number">-1</span></span><br><span class="line">    <span class="keyword">for</span> index,value <span class="keyword">in</span> enumerate(name):</span><br><span class="line">        result += name[max_index-index]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">name = <span class="string">'abcd'</span></span><br><span class="line">result = func(name)</span><br></pre></td></tr></table></figure><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>此处 enumerate()为python内置函数，用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。用法如下：</p><p>enumerate(sequence, [start=0])</p><ul><li><p>sequence – 一个序列、迭代器或其他支持迭代对象。</p></li><li><p>start – 下标起始位置。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons))</span><br><span class="line">[(<span class="number">0</span>, <span class="string">'Spring'</span>), (<span class="number">1</span>, <span class="string">'Summer'</span>), (<span class="number">2</span>, <span class="string">'Fall'</span>), (<span class="number">3</span>, <span class="string">'Winter'</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(enumerate(seasons, start=<span class="number">1</span>))       <span class="comment"># 下标从 1 开始</span></span><br><span class="line">[(<span class="number">1</span>, <span class="string">'Spring'</span>), (<span class="number">2</span>, <span class="string">'Summer'</span>), (<span class="number">3</span>, <span class="string">'Fall'</span>), (<span class="number">4</span>, <span class="string">'Winter'</span>)]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>seq = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i, element <span class="keyword">in</span> enumerate(seq):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> i, element</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="number">0</span> one</span><br><span class="line"><span class="number">1</span> two</span><br><span class="line"><span class="number">2</span> three</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之函数装饰器(二)</title>
      <link href="/2020/02/04/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8-%E4%BA%8C/"/>
      <url>/2020/02/04/Python%E4%B9%8B%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<p>继续上次的进度</p><h4 id="装饰类"><a href="#装饰类" class="headerlink" title="装饰类"></a>装饰类</h4><p>在类中有两种不同的方式使用装饰器，第一个和我们之前做过的函数非常相似:在类的方法上应用。这也是当时引入装饰器的原因之一</p><p>一些常用的装饰器已经内置到python中，像@classmethod @staticmethod @property。  </p><p>下面的Circle 类使用了@classmethod @staticmethod和@property三个装饰器</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python之函数装饰器(一)</title>
      <link href="/2020/02/03/Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
      <url>/2020/02/03/Python%E5%87%BD%E6%95%B0%E8%A3%85%E9%A5%B0%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>装饰器(Decorators)是python中最具特色且重要的一部分。</p><p>从功能上讲：装饰器的作用就是给已有的函数添加额外的功能，起到装饰的作用。</p><p>从定义上讲：装饰器就是一个函数，它接收一个函数作为参数并扩展这个函数的功能，但又不会去修改这个函数的内部，从而提高代码的复用性。</p><p>看一下装饰器长啥样(talk is cheap, show me the code)<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个新的装饰器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorators</span><span class="params">(a_func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'I am doing some boring work before executing a_func()'</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        print(<span class="string">'I am doing some boring work after executing a_func()'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用装饰器装饰函数</span></span><br><span class="line"><span class="meta">@a_new_decorators</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的函数</span></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果如下：</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="string">I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="string">I am doing some boring work after executing a_func()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></p><p>下面通过代码的演变来理解装饰器的实现原理</p><h4 id="一等对象"><a href="#一等对象" class="headerlink" title="一等对象"></a>一等对象</h4><p>在python中，函数是一等对象，意思是函数可以作为参数被传递，就像其它的对象(string，int，float，list和其它)，思考下面的三个函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Hello <span class="subst">&#123;name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_awesome</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Yo <span class="subst">&#123;name&#125;</span>, together we are the awesomest!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet_bob</span><span class="params">(greeter_func)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> greeter_func(<span class="string">"Bob"</span>)</span><br></pre></td></tr></table></figure></p><p>在这里,say_hello()和be_awsone()是常规函数，接收一个name参数返回一个字符串，然而greet_bob()函数，接收一个函数作为他的参数，我们可以将say_hello()或者be_awesome()函数传递给它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet_bob(say_hello)</span><br><span class="line"><span class="string">'Hello Bob'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet_bob(be_awesome)</span><br><span class="line"><span class="string">'Yo Bob, together we are the awesomest!'</span></span><br></pre></td></tr></table></figure></p><p>这里将函数名 say_hello 和 be_awsone 作为参数分别去调用函数greet_bob，但是并没有直接使用()，而是通过函数名引用函数，在greet_bob内部去通过()调用。</p><h4 id="内部函数"><a href="#内部函数" class="headerlink" title="内部函数"></a>内部函数</h4><p>在函数内部被定义的函数叫做内部函数，如下是内部函数的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Printing from the parent() function"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_child</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Printing from the first_child() function"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second_child</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Printing from the second_child() function"</span>)</span><br><span class="line"></span><br><span class="line">    second_child()</span><br><span class="line">    first_child()</span><br></pre></td></tr></table></figure></p><p>调用函数parent(),看一下输出的结果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>parent()</span><br><span class="line">Printing <span class="keyword">from</span> the parent() function</span><br><span class="line">Printing <span class="keyword">from</span> the second_child() function</span><br><span class="line">Printing <span class="keyword">from</span> the first_child() function</span><br></pre></td></tr></table></figure></p><p>注意，内部函数的定义顺序无所谓，只会根据调用的顺序来按照顺序执行；<br>而且，内部函数在父函数被调用之前不会生效，他们的作用域在副函数的内部，只作为局部变量存在父函数的内部，直接调用内部函数 first_child(),你会得到如下错误：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">NameError: name <span class="string">'first_child'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure></p><p>不管什么时候调用函数parent(),内部函数都会被调用，因为他们的局部作用域，无法在父函数之外使用。</p><h4 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h4><p>在python中允许使用函数来作为返回值，如下是在函数parent中返回内部函数的函数名<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parent</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">first_child</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hi, I am Emma"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">second_child</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Call me Liam"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> first_child</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> second_child</span><br></pre></td></tr></table></figure></p><p>注意，这里返回的是内部函数名，也就是对内部函数的引用，而带()是指对函数求值的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first = parent(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second = parent(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>first</span><br><span class="line">&lt;function parent.&lt;locals&gt;.first_child at <span class="number">0x7f599f1e2e18</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second</span><br><span class="line">&lt;function parent.&lt;locals&gt;.second_child at <span class="number">0x7f599dad5268</span>&gt;</span><br></pre></td></tr></table></figure></p><p>由输出的结果可知：这个输出代表first变量引用了在parent()中的内部函数first_child()，second则指向了second_child()</p><p>现在就可以像常规函数一样使用first和second，虽然他们指向的函数无法被直接访问。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>first()</span><br><span class="line"><span class="string">'Hi, I am Emma'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>second()</span><br><span class="line"><span class="string">'Call me Liam'</span></span><br></pre></td></tr></table></figure></p><h4 id="简单装饰器"><a href="#简单装饰器" class="headerlink" title="简单装饰器"></a>简单装饰器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Something is happening before the function is called.'</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">'Something is happening after the function is called.'</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Whee！'</span>)</span><br><span class="line">    </span><br><span class="line">say_whee = my_decorator(say_whee)</span><br></pre></td></tr></table></figure><p>再直接调用say_whee的输出为：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">Something <span class="keyword">is</span> happening before the function <span class="keyword">is</span> called.</span><br><span class="line">Whee!</span><br><span class="line">Something <span class="keyword">is</span> happening after the function <span class="keyword">is</span> called.</span><br></pre></td></tr></table></figure></p><p>可以看到装饰器的作用，只是简单调用了say_whee函数，却执行了额外的操作。</p><p>所谓的装饰器就发生在 say_whee = my_decorator(say_whee) 这一句。</p><p>事实上，say_whee 现在指向的是内部函数 wrapper,当在调用my_decorator(say_whee) 的时候将wrapper作为函数返回<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee</span><br><span class="line">&lt;function my_decorator.&lt;locals&gt;.wrapper at <span class="number">0x7f3c5dfd42f0</span>&gt;</span><br></pre></td></tr></table></figure></p><p>wrapper()引用原始的say_whee()函数内存地址赋值给了变量func，然后在两个print之间去调用它</p><p>简言之：装饰器包裹一个函数，并改变他的行为。</p><p>看下面一个例子，装饰器可以动态的来修改函数，所以我们定义一个函数只在白天执行，夜晚就不打扰您休息了<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">not_during_the_night</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">7</span> &lt;= datetime.now().hour &lt; <span class="number">22</span>:</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span>  <span class="comment"># Hush, the neighbors are asleep</span></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Whee!"</span>)</span><br><span class="line"></span><br><span class="line">say_whee = not_during_the_night(say_whee)</span><br></pre></td></tr></table></figure></p><p>如果你在睡觉时间调用该函数不会发生任何事情，因为装饰器的作用就是让这个函数在白天执行<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><h4 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h4><p>上面的装饰器say_whee()用起来有一点笨拙。首先，你键入了三次say_whee，另外，装饰器隐藏在了函数的定义之下作为替代，<br>python允许你使用@symbol的方式使用装饰器，有时被称为”pie”语法，下面的例子和之前第一个装饰器实现了同样的效果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"Something is happening before the function is called."</span>)</span><br><span class="line">        func()</span><br><span class="line">        print(<span class="string">"Something is happening after the function is called."</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Whee!"</span>)</span><br></pre></td></tr></table></figure></p><p>所以，@my_decorator 只是say_whee = my_decorator(say_whee)的一种快捷方式，这就是装饰器的用法</p><h4 id="复用装饰器"><a href="#复用装饰器" class="headerlink" title="复用装饰器"></a>复用装饰器</h4><p>下面创建了一个decorator.py<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line">        func()</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p><p>再在另外一个py文件中导入这个复用装饰器<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_whee</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Whee!'</span>)</span><br></pre></td></tr></table></figure></p><p>最后运行这个例子，你会发现 say_whee()函数执行了两次<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">Whee!</span><br><span class="line">Whee!</span><br></pre></td></tr></table></figure></p><h4 id="装饰器传参"><a href="#装饰器传参" class="headerlink" title="装饰器传参"></a>装饰器传参</h4><p>当被装饰的函数需要需要传入参数，这时函数还能正常运行吗？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Hello &#123;&#125;'</span>.format(name))</span><br></pre></td></tr></table></figure></p><p>报错了，预料之中<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet(<span class="string">"World"</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: wrapper_do_twice() takes <span class="number">0</span> positional arguments but <span class="number">1</span> was given</span><br></pre></td></tr></table></figure></p><p>原因在于，装饰器内部函数wrapper_do_twice()定义的时候并没有接收参数，你可以重新定义wrapper_do_twice()函数来接收一个参数，但是前面被装饰的函数say_whee()就会报错，<br>因为它并不需要传递一个参数。</p><p>所以装饰器的传参，是在内部函数中使用 *args 和 **kwargs,它可以接受任意个的关键字参数，然后来修改decorator.py：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p><p>此bug已修复<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee()</span><br><span class="line">Whee!</span><br><span class="line">Whee!</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>greet(<span class="string">"World"</span>)</span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure></p><h4 id="从装饰器返回值"><a href="#从装饰器返回值" class="headerlink" title="从装饰器返回值"></a>从装饰器返回值</h4><p>被装饰的函数返回值会发生什么？<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> do_twice</span><br><span class="line"></span><br><span class="line"><span class="meta">@do_twice</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">return_greeting</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'Creating greeting!'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello &#123;&#125;'</span>.format(name)</span><br></pre></td></tr></table></figure></p><p>运行：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>hi_adam = return_greeting(<span class="string">"Adam"</span>)</span><br><span class="line">Creating greeting</span><br><span class="line">Creating greeting</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(hi_adam)</span><br><span class="line"><span class="literal">None</span></span><br></pre></td></tr></table></figure></p><p>发现函数的返回值被装饰器吃了</p><p>因为装饰器的内部函数do_twice_wrapper()没有返回值，故返回为None。</p><p>所以我们要在内部函数中返回被装饰的函数的返回值，修改decorator.py如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p><p>再次调用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>return_greeting(<span class="string">"Adam"</span>)</span><br><span class="line">Creating greeting</span><br><span class="line">Creating greeting</span><br><span class="line"><span class="string">'Hi Adam'</span></span><br></pre></td></tr></table></figure></p><h4 id="你是谁"><a href="#你是谁" class="headerlink" title="你是谁"></a>你是谁</h4><p>在使用Python(尤其是在交互式shell中)时，强大的内省是非常方便的功能。内省是对象在运行时了解其自身属性的能力。例如，函数知道自己的名称和文档:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="keyword">print</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span>.__name__</span><br><span class="line"><span class="string">'print'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(<span class="keyword">print</span>)</span><br><span class="line">Help on built-<span class="keyword">in</span> function <span class="keyword">print</span> <span class="keyword">in</span> module builtins:</span><br><span class="line"></span><br><span class="line">print(...)</span><br><span class="line">    &lt;full help message&gt;</span><br></pre></td></tr></table></figure></p><p>内省同样适用于你自定义的函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee</span><br><span class="line">&lt;function do_twice.&lt;locals&gt;.wrapper_do_twice at <span class="number">0x7f43700e52f0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee.__name__</span><br><span class="line"><span class="string">'wrapper_do_twice'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(say_whee)</span><br><span class="line">Help on function wrapper_do_twice <span class="keyword">in</span> module decorators:</span><br><span class="line"></span><br><span class="line">wrapper_do_twice()</span><br></pre></td></tr></table></figure></p><p>然而say_whee()函数却显示为装饰器内部函数do_twice_wrapper()</p><p>为了修复这个，装饰器需要使用@functools.wraps装饰器，它会保留原始函数的信息，再次更新下decorators.py:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_twice</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_do_twice</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_do_twice</span><br></pre></td></tr></table></figure></p><p>不需要对函数say_whee()做任何修改<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee</span><br><span class="line">&lt;function say_whee at <span class="number">0x7ff79a60f2f0</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>say_whee.__name__</span><br><span class="line"><span class="string">'say_whee'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>help(say_whee)</span><br><span class="line">Help on function say_whee <span class="keyword">in</span> module whee:</span><br><span class="line"></span><br><span class="line">say_whee()</span><br></pre></td></tr></table></figure></p><p>技术细节:@funtools.wraps 装饰器使用函数functools.update_wrapper()来更新指定的属性，像<strong>name</strong>和<strong>doc</strong>来用于自省</p><h4 id="一些现实中使用的例子"><a href="#一些现实中使用的例子" class="headerlink" title="一些现实中使用的例子"></a>一些现实中使用的例子</h4><p>我们来看一些用处更大的装饰器例子。你会注意到他们主要的模式和你现在所学的都是一样的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_decorator</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># Do something before</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        <span class="comment"># Do something after</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper_decorator</span><br></pre></td></tr></table></figure><p>对于构建更复杂的函数这是一个很好的模版</p><h4 id="时间函数"><a href="#时间函数" class="headerlink" title="时间函数"></a>时间函数</h4><p>@timer 装饰器，他会测量函数的运行时间，并且打印持续时间到控制台，代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Print the runtime of the decorated function"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_timer</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        start_time = time.perf_counter()    <span class="comment"># 1</span></span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        end_time = time.perf_counter()      <span class="comment"># 2</span></span><br><span class="line">        run_time = end_time - start_time    <span class="comment"># 3</span></span><br><span class="line">        print(<span class="string">f"Finished <span class="subst">&#123;func.__name__&#125;</span> in <span class="subst">&#123;run_time:<span class="number">.4</span>f&#125;</span> secs"</span>)</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper_timer</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">waste_some_time</span><span class="params">(num_times)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(num_times):</span><br><span class="line">        sum([i**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000</span>)])</span><br></pre></td></tr></table></figure></p><p>这个装饰器在函数运行之前获取时间，在函数执行完之后又获取了一次时间，最后做差求得执行时间，使用time.perf_counter()函数，可以很精准的计算时间间隔，执行结果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>waste_some_time(<span class="number">1</span>)</span><br><span class="line">Finished <span class="string">'waste_some_time'</span> <span class="keyword">in</span> <span class="number">0.0010</span> secs</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>waste_some_time(<span class="number">999</span>)</span><br><span class="line">Finished <span class="string">'waste_some_time'</span> <span class="keyword">in</span> <span class="number">0.3260</span> secs</span><br></pre></td></tr></table></figure></p><h4 id="调试代码"><a href="#调试代码" class="headerlink" title="调试代码"></a>调试代码</h4><p>下面的@debug装饰器会在每次被调用的时候打印函数传入的参数和执行返回的结果。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Print the function signature and return value"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_debug</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        args_repr = [repr(a) <span class="keyword">for</span> a <span class="keyword">in</span> args]                      <span class="comment"># 将args创建为列表，使用repr修饰</span></span><br><span class="line">        kwargs_repr = [<span class="string">f"<span class="subst">&#123;k&#125;</span>=<span class="subst">&#123;v!r&#125;</span>"</span> <span class="keyword">for</span> k, v <span class="keyword">in</span> kwargs.items()]  <span class="comment"># 将kwargs创建为列表，使用f-string格式化参数为key=value，!r表示使用repr()表示值</span></span><br><span class="line">        signature = <span class="string">", "</span>.join(args_repr + kwargs_repr)           <span class="comment"># args和kwargs转换后会合并在signature变量中，使用逗号分隔每个变量</span></span><br><span class="line">        print(<span class="string">f"Calling <span class="subst">&#123;func.__name__&#125;</span>(<span class="subst">&#123;signature&#125;</span>)"</span>)</span><br><span class="line">        value = func(*args, **kwargs)</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;func.__name__!r&#125;</span> returned <span class="subst">&#123;value!r&#125;</span>"</span>)           <span class="comment"># 函数运行结束后会返回值</span></span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">    <span class="keyword">return</span> wrapper_debug</span><br></pre></td></tr></table></figure></p><p>下面来测试一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@debug</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_greeting</span><span class="params">(name, age=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> age <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Howdy <span class="subst">&#123;name&#125;</span>!"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"Whoa <span class="subst">&#123;name&#125;</span>! <span class="subst">&#123;age&#125;</span> already, you are growing up!"</span></span><br></pre></td></tr></table></figure></p><p>注意@debug装饰器如何打印make_greeting()函数的signature 和返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_greeting(<span class="string">"Benjamin"</span>)</span><br><span class="line">Calling make_greeting(<span class="string">'Benjamin'</span>)</span><br><span class="line"><span class="string">'make_greeting'</span> returned <span class="string">'Howdy Benjamin!'</span></span><br><span class="line"><span class="string">'Howdy Benjamin!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_greeting(<span class="string">"Richard"</span>, age=<span class="number">112</span>)</span><br><span class="line">Calling make_greeting(<span class="string">'Richard'</span>, age=<span class="number">112</span>)</span><br><span class="line"><span class="string">'make_greeting'</span> returned <span class="string">'Whoa Richard! 112 already, you are growing up!'</span></span><br><span class="line"><span class="string">'Whoa Richard! 112 already, you are growing up!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>make_greeting(name=<span class="string">"Dorrisile"</span>, age=<span class="number">116</span>)</span><br><span class="line">Calling make_greeting(name=<span class="string">'Dorrisile'</span>, age=<span class="number">116</span>)</span><br><span class="line"><span class="string">'make_greeting'</span> returned <span class="string">'Whoa Dorrisile! 116 already, you are growing up!'</span></span><br><span class="line"><span class="string">'Whoa Dorrisile! 116 already, you are growing up!'</span></span><br></pre></td></tr></table></figure><h4 id="给代码降速"><a href="#给代码降速" class="headerlink" title="给代码降速"></a>给代码降速</h4><p>场景如下，对一个检查资源是否存在的函数进行速度限制。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">slow_down</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Sleep 1 second before calling the function"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_slow_down</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_slow_down</span><br><span class="line"></span><br><span class="line"><span class="meta">@slow_down</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">(from_number)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> from_number &lt; <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"Liftoff!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(from_number)</span><br><span class="line">        countdown(from_number - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>countdown()函数是一个递归函数,执行如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>countdown(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line">Liftoff!</span><br></pre></td></tr></table></figure></p><h4 id="注册插件"><a href="#注册插件" class="headerlink" title="注册插件"></a>注册插件</h4><p>可以利用装饰器的原理，将函数注册到一个字典里，但不对函数做额外的操作，将其解包后返回，如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">PLUGINS = dict()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Register a function as a plug-in"""</span></span><br><span class="line">    PLUGINS[func.__name__] = func</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say_hello</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Hello <span class="subst">&#123;name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">be_awesome</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"Yo <span class="subst">&#123;name&#125;</span>, together we are the awesomest!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomly_greet</span><span class="params">(name)</span>:</span></span><br><span class="line">    greeter, greeter_func = random.choice(list(PLUGINS.items()))</span><br><span class="line">    print(<span class="string">f"Using <span class="subst">&#123;greeter!r&#125;</span>"</span>)</span><br><span class="line">    <span class="keyword">return</span> greeter_func(name)</span><br></pre></td></tr></table></figure></p><p>@register装饰器只是在全局PLUGINS 字典中储存了被装饰函数的引用。</p><p>注意你不需要在例子中写内部函数或者使用@functools.wraps ，因为返回的是一个未经过修改的初始函数。</p><p>randomly_greet()函数在注册函数中随机选择一个使用。注意PLUGINS字典已经包含了对注册为插件的每个函数对象的引用:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>PLUGINS</span><br><span class="line">&#123;<span class="string">'say_hello'</span>: &lt;function say_hello at <span class="number">0x7f768eae6730</span>&gt;,</span><br><span class="line"> <span class="string">'be_awesome'</span>: &lt;function be_awesome at <span class="number">0x7f768eae67b8</span>&gt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>randomly_greet(<span class="string">"Alice"</span>)</span><br><span class="line">Using <span class="string">'say_hello'</span></span><br><span class="line"><span class="string">'Hello Alice'</span></span><br></pre></td></tr></table></figure></p><p>这个插件的主要用处在于不需要再单独维护一个插件列表。这个列表在插件注册时自动创建，使得添加一个新插件变得很简单，只需定义函数并用@register装饰即可。</p><p>如果你对python中的globals()函数熟悉，你可能会看到一些和我们的插件结构相似之处。globals()可以访问当前作用于的所有全局变量<br>包括我们的插件:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>globals()</span><br><span class="line">&#123;..., <span class="comment"># Lots of variables not shown here.</span></span><br><span class="line"> <span class="string">'say_hello'</span>: &lt;function say_hello at <span class="number">0x7f768eae6730</span>&gt;,</span><br><span class="line"> <span class="string">'be_awesome'</span>: &lt;function be_awesome at <span class="number">0x7f768eae67b8</span>&gt;,</span><br><span class="line"> <span class="string">'randomly_greet'</span>: &lt;function randomly_greet at <span class="number">0x7f768eae6840</span>&gt;&#125;</span><br></pre></td></tr></table></figure></p><p>使用@register 装饰器还可以创建感兴趣的变量管理列表，有效地从globals()中筛选出一些函数</p><h4 id="web应用中的权限验证"><a href="#web应用中的权限验证" class="headerlink" title="web应用中的权限验证"></a>web应用中的权限验证</h4><p>我们在web应用中一些有权限的页面只能在用户登录之后才能被访问，可以给该页面的路由函数使用权限验证的装饰器，来进行登陆权限的校验，<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask, g, request, redirect, url_for</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login_required</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""Make sure user is logged in before proceeding"""</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper_login_required</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> g.user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(url_for(<span class="string">"login"</span>, next=request.url))</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> wrapper_login_required</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route("/secret")</span></span><br><span class="line"><span class="meta">@login_required</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">secret</span><span class="params">()</span>:</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>上面的内容就是flask框架中，使用装饰器实现权限验证的操作。</p><p>以上就是介绍的如何创建简单的装饰器，并且非常了解什么是装饰器以及它们是如何工作的。</p><p>在下一篇中回去研究一下装饰器的一些高级用法：</p><ul><li>1、在类上使用装饰器(装饰类)</li><li>2、在一个函数上应用多个装饰器</li><li>3、带参数的装饰器</li><li>4、可以选择是否接收参数的装饰器</li><li>5、带状态的装饰器</li><li>6、类装饰器</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之上下文管理器</title>
      <link href="/2020/02/01/python%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2020/02/01/python%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>每一个用python的人都知道用with open来操作文本资源，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><h4 id="一、为什么使用with来操作文本文件？"><a href="#一、为什么使用with来操作文本文件？" class="headerlink" title="一、为什么使用with来操作文本文件？"></a>一、为什么使用with来操作文本文件？</h4><p>对于系统资源如文件、数据库连接、socket而言，应用程序在打开这些资源并且执行完业务逻辑操作之后，<br>必须要做的一件事就是关闭（断开）该资源。</p><p>例如python打开一个文本文件并写入一段内容之后，如果频繁打开写入文件不做关闭操作，就会出现”too many open files”的错误，<br>因为系统允许打开同一个文件的次数是有限的。</p><p>同样，对于数据库，如果连接次数过多而没有及时关闭的话，就可能会出现”Can not<br>connect to MySQL server Too many connections”,因为数据库的连接是非常珍贵的资源，不可能无限制的创建连接。</p><p>正确的操作一个资源文件，如下：</p><h5 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    f = open(filename,<span class="string">'w'</span>)</span><br><span class="line">    f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><p>这种方式比较繁琐，每次在操作完文件之后还要关闭，如果在写入过程中出现错误，<br>就会直接终止整段程序，所以要加入try异常捕获机制。</p><h5 id="捕获异常版"><a href="#捕获异常版" class="headerlink" title="捕获异常版"></a>捕获异常版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = open(filename,<span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        print(<span class="string">'打开文件 &#123;&#125; 出现异常'</span>.format(filename))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><p>这种方式就会避免程序终止，在finally最后会对文件进行close关闭操作。</p><h5 id="with简洁版"><a href="#with简洁版" class="headerlink" title="with简洁版"></a>with简洁版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><p>当离开 with 缩紧的代码块时，会自动调用 f.close() 关闭，由此可知 with 就相当于前一个版本的 try/finally。<br>此处with的实现原理就是上下文管理器（Context Manager）。</p><h4 id="二、什么是上下文管理器（Context-Manager）"><a href="#二、什么是上下文管理器（Context-Manager）" class="headerlink" title="二、什么是上下文管理器（Context Manager）"></a>二、什么是上下文管理器（Context Manager）</h4><p>任何实现了<strong>enter</strong>() 和<strong>exit</strong>() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。显然，文件（file）对象也实现了上下文管理器。</p><p>那么文件对象是如何实现这两个方法的呢？我们可以模拟实现一个自己的文件类，让该类实现<strong>enter</strong>() 和<strong>exit</strong>() 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, mode)</span>:</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"entering"</span>)</span><br><span class="line">        self.f = open(self.filename, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        print(<span class="string">"exiting"</span>)</span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用自定义的File类来执行一下</span></span><br><span class="line">    <span class="keyword">with</span> File(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">         f.write(<span class="string">"test one two tree four"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>其中<strong>enter</strong>() 方法返回资源对象，这里就是你将要打开的那个文件对象f，而<strong>exit</strong>()方法可以处理一些清除工作。<br>因为 File类 实现了上下文管理器，现在就可以使用 with 语句来操作资源文件。</p><h4 id="三、-contextmanager-装饰器实现上下文管理器"><a href="#三、-contextmanager-装饰器实现上下文管理器" class="headerlink" title="三、@contextmanager 装饰器实现上下文管理器"></a>三、@contextmanager 装饰器实现上下文管理器</h4><p>python 还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。<br>通过 yield 将函数分割成两部分，yield 之前的语句在<strong>enter</strong> 方法中执行，yield 之后的语句在 <strong>exit</strong> 方法中执行。紧跟在 yield 后面的值是函数的返回值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_open</span><span class="params">(path,mode)</span>:</span></span><br><span class="line">    f = open(path,mode)    <span class="comment">## __enter__</span></span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    f.close()        <span class="comment">## __exit__</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用自定义的File类来执行一下</span></span><br><span class="line">    <span class="keyword">with</span> my_open(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">         f.write(<span class="string">"test one two tree four"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>python 提供了 with 语法用于简化资源操作的后续清除操作，是 try/finally 的替代方法，实现原理建立在上下文管理器之上。<br>此外，python 还提供的 contextmanager 装饰器，更进一步简化上下管理器的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx+uwsgi+flask/django部署web服务</title>
      <link href="/2019/06/18/nginx-uwsgi-flask-django%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/06/18/nginx-uwsgi-flask-django%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用nginx+uwsgi+flask 部署web服务</p><h4 id="一、放置项目文件"><a href="#一、放置项目文件" class="headerlink" title="一、放置项目文件"></a>一、放置项目文件</h4><p>将项目文件夹放到服务器上</p><p>1.ssh 远程连接服务器,登陆密码 JYcxys@3030<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">python</span>@<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">1</span>.<span class="keyword">150</span></span><br></pre></td></tr></table></figure></p><p>2.使用 scp 将本地项目文件放到服务器上的 /home/python/workspace 工作目录下<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /Users/hu-a-u/MyCode/work/yct_worker python<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">150</span><span class="symbol">:/home/python/workspace</span></span><br></pre></td></tr></table></figure></p><p>如果是文件夹需要带上 -r 参数</p><h4 id="二、编写uwsgi的-ini文件（一般需要sudo）"><a href="#二、编写uwsgi的-ini文件（一般需要sudo）" class="headerlink" title="二、编写uwsgi的.ini文件（一般需要sudo）"></a>二、编写uwsgi的.ini文件（一般需要sudo）</h4><p>.ini 文件用于运行服务，<br>在服务器的 /etc/nginx 目录下创建一个ini文件<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">nano</span> <span class="selector-tag">demo</span><span class="selector-class">.ini</span></span><br></pre></td></tr></table></figure></p><p>内容如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">chdir</span> = /home/python/workspace/demo #项目文件夹</span><br><span class="line"><span class="attr">wsgi-file</span> = /home/python/workspace/demo/manage.py #项目启动py文件</span><br><span class="line"><span class="attr">home</span> = /home/python/.virtualenvs/py3_flask/ #项目运行的虚拟环境</span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">socket</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5002</span> #运行在一个端口</span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">enable-threads</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="attr">daemonize</span> = %(chdir)/uwsgi.log #uwsig的日志文件</span><br><span class="line"><span class="attr">stats</span>=%(chdir)/export_flask_uwsgi_out.status #运行状态文件</span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/export_flask_uwsgi_out.pid #记录运行的进程号，便于重启uwsgi服务</span><br><span class="line"><span class="attr">callable</span> = app</span><br></pre></td></tr></table></figure></p><p>django项目<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">chdir</span> = /home/python/workspace/cicjust_TaxSb/</span><br><span class="line"><span class="attr">wsgi-file</span> = /home/python/workspace/cicjust_TaxSb/confg/wsgi.py</span><br><span class="line"><span class="attr">home</span> = /home/python/.virtualenvs/django_py3/</span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">socket</span> =<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="attr">daemonize</span> = %(chdir)/uwsgi.log</span><br><span class="line"><span class="attr">stats</span>=%(chdir)/uwsgi.status</span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/uwsgi.pid</span><br></pre></td></tr></table></figure></p><p>chdir 是项目的文件夹路径</p><p>wsgi-file 是项目运行的py文件</p><p>home 是项目运行的环境依赖，虚拟环境</p><p>socket 运行在服务器地址</p><p>daemonize 记录日志</p><p>callable 指出的是具体执行.run方法的那个实体的名字，一般而言都是’app=Flask(<strong>name</strong>)’所以这里是app</p><h4 id="三、启动uwsgi"><a href="#三、启动uwsgi" class="headerlink" title="三、启动uwsgi"></a>三、启动uwsgi</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi <span class="params">--ini</span> <span class="string">/etc/nginx/demo.ini</span></span><br></pre></td></tr></table></figure><p>一般不需要加sudo，启动后监听端口5002是否已经在运行，使用 netstat -lntp 命令<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ netstat -lntp</span><br><span class="line">Proto Recv-Q Send-Q Local<span class="built_in"> Address </span>          Foreign<span class="built_in"> Address </span>        State       PID/Program name</span><br><span class="line">tcp        0      0 127.0.0.1:5002          0.0.0.0:*               LISTEN      3603/uwsgi</span><br></pre></td></tr></table></figure></p><h4 id="四、配置nginx并启动"><a href="#四、配置nginx并启动" class="headerlink" title="四、配置nginx并启动"></a>四、配置nginx并启动</h4><p>nginx的配置在 /etc/nginx/sites-available<br>切换到目录下，sudo创建一个文件没有后缀</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo nano demo</span></span><br></pre></td></tr></table></figure><p>配置内容如下:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        listen 6600 ; //默认的web访问端口</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">6600</span> ; </span><br><span class="line"></span><br><span class="line">        server_name 116.228.88.888; //对外访问的地址，也可以是域名</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">               alias /home/python/workspace/demo/static; //静态文件的目录</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /  &#123;</span><br><span class="line">               uwsgi_pass 127.0.0.1:5002;  //需要和uwsgi的配置文件里socket项的地址相同,否则无法让uwsgi接收到请求。</span><br><span class="line">               include /etc/nginx/uwsgi_params; //这里是导入的uwsgi配置</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文件创建完成之后，创建软链到 /etc/nginx/sites-enabled 目录下，命令<br>ln -s [源文件全路径] [目标文件全路径]<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>demo <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>demo</span><br></pre></td></tr></table></figure></p><p>这样配置完后，需要重启nginx服务<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo nginx -s reload</span></span><br></pre></td></tr></table></figure></p><p>当外部有一个6600端口的请求送到本机时，先让nginx开始处理。<br>nginx进行一些处理之后转发给这里配置的uwsgi_pass地址，刚好传送给uwsgi处理。<br>再由uwsgi来调用项目中的代码处理请求返回。</p><h4 id="五、注意"><a href="#五、注意" class="headerlink" title="五、注意"></a>五、注意</h4><p>服务都运行正常后，用浏览器访问不了，检查防火墙是否开启6600这个端口</p><p>查看防火墙状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ sudo firewall-cmd --state</span><br><span class="line">running</span><br></pre></td></tr></table></figure></p><p>说明防火墙已开启</p><p>查看已开放的端口<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python<span class="meta">@python</span>-<span class="string">splinter:</span>/$ sudo firewall-cmd --list-ports</span><br><span class="line"><span class="number">5000</span><span class="regexp">/tcp 5002/</span>tcp <span class="number">5500</span><span class="regexp">/tcp 5005/</span>tcp <span class="number">5006</span><span class="regexp">/tcp 8000/</span>tcp <span class="number">5008</span><span class="regexp">/tcp 12233/</span>tcp</span><br></pre></td></tr></table></figure></p><p>可以看到没有6600端口，然后防火墙开启6600端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ sudo firewall-cmd --zone=public --add-port=6600/tcp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>开启成功后需要重启防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ sudo firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>然后使用浏览器访问成功</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> uwsgi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> uwsgi </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>celery开启flower后台监控任务执行状态(docker)</title>
      <link href="/2019/06/17/celery%E5%BC%80%E5%90%AFflower%E5%90%8E%E5%8F%B0%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
      <url>/2019/06/17/celery%E5%BC%80%E5%90%AFflower%E5%90%8E%E5%8F%B0%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="使用flower容器进行worker后台监控"><a href="#使用flower容器进行worker后台监控" class="headerlink" title="使用flower容器进行worker后台监控"></a>使用flower容器进行worker后台监控</h3><p>使用容器，部署在192.168.1.230</p><p>监听本地worker的容器名称 yct_flower,内网访问地址 192.168.1.230:5555<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewukkg9xj327w0oyjw7.jpg" alt></p><p>监听阿里云worker的容器名称 aliyun01_flower,内网访问地址 192.168.1.230:5559<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewttogd1j327w0oetdq.jpg" alt></p><p>文件夹目录下只有三个有用文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── README.md</span><br><span class="line">├── docker-entrypoint.sh</span><br><span class="line">└── requirements.txt</span><br></pre></td></tr></table></figure></p><hr><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> requirements.txt /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libfontconfig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> BROKER_HOST <span class="number">47.102</span>.<span class="number">218.137</span></span><br><span class="line"><span class="keyword">ENV</span> BROKER_PORT <span class="number">5672</span></span><br><span class="line"><span class="keyword">ENV</span> VIRTUAL_HOST <span class="string">'yct'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5555</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /code/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><hr><h4 id="docker-entrypoint-sh启动文件"><a href="#docker-entrypoint-sh启动文件" class="headerlink" title="docker-entrypoint.sh启动文件"></a>docker-entrypoint.sh启动文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">celery flower --broker=amqp://cic_admin:JYcxys@3030@<span class="variable">$BROKER_HOST</span>:<span class="variable">$BROKER_PORT</span>/<span class="variable">$VIRTUAL_HOST</span></span><br></pre></td></tr></table></figure><hr><h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">celery</span>==<span class="number">4.3</span>.<span class="number">0</span>rc1</span><br><span class="line"><span class="attr">flower</span>==<span class="number">0.9</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --env <span class="attribute">BROKER_HOST</span>=47.102.218.137 --env <span class="attribute">BROKER_PORT</span>=5672 --env <span class="attribute">VIRTUAL_HOST</span>=<span class="string">'yct'</span> --name flower -p 5555:5555 -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --env <span class="attribute">BROKER_HOST</span>=47.102.218.137 --env <span class="attribute">BROKER_PORT</span>=5672 --env <span class="attribute">VIRTUAL_HOST</span>=<span class="string">'newproxy-yuanqu01'</span> --name flower -p 5559:5555 -d [镜像名称]</span><br></pre></td></tr></table></figure><p>其中 BROKER_HOST 、BROKER_PORT 和 VIRTUAL_HOST 为环境变量</p><p>BROKER_HOST 、BROKER_PORT 指定消息队列地址和端口</p><p>VIRTUAL_HOST 指定消息队列的的 vhost名称</p><hr><h4 id="镜像地址（此处是我自己的镜像地址，后面可以自己打包）"><a href="#镜像地址（此处是我自己的镜像地址，后面可以自己打包）" class="headerlink" title="镜像地址（此处是我自己的镜像地址，后面可以自己打包）"></a>镜像地址（此处是我自己的镜像地址，后面可以自己打包）</h4><p>daocloud.io/huhuhuhu/flower_docker:latest</p><hr><p>当监控下的任务太多时，重启flower容器，将前面的任务记录清空<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">restart</span> yct_flower</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> celery </tag>
            
            <tag> flower </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yct_proxy和yct_worker的部署地址</title>
      <link href="/2019/06/17/yct-proxy%E5%92%8Cyct-worker%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/06/17/yct-proxy%E5%92%8Cyct-worker%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h3><p>yct_proxy代码:<a href="https://github.com/HU-A-U/my-proxy" target="_blank" rel="noopener">https://github.com/HU-A-U/my-proxy</a></p><p>yct_worker代码:<a href="https://github.com/HU-A-U/yct_worker" target="_blank" rel="noopener">https://github.com/HU-A-U/yct_worker</a></p><p>分支 aliyun 是 部署在阿里云上的服务的代码内容，不需要合并</p><hr><h3 id="阿里云RabbitMQ后台管理地址"><a href="#阿里云RabbitMQ后台管理地址" class="headerlink" title="阿里云RabbitMQ后台管理地址"></a>阿里云RabbitMQ后台管理地址</h3><p><a href="http://47.102.218.137:15672" target="_blank" rel="noopener">http://47.102.218.137:15672</a></p><p>用户名：cic_admin</p><p>密码：JYcxys@3030</p><hr><h3 id="本地服务器-cic-odoo"><a href="#本地服务器-cic-odoo" class="headerlink" title="本地服务器 cic-odoo"></a>本地服务器 cic-odoo</h3><h4 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">1</span>.<span class="keyword">230</span></span><br></pre></td></tr></table></figure><h4 id="镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）"><a href="#镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）" class="headerlink" title="镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）"></a>镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）</h4><p>本地服务proxy镜像地址</p><p>daocloud.io/huhuhuhu/new_proxy:latest</p><p>本地服务worker镜像地址</p><h4 id="运行的容器名称"><a href="#运行的容器名称" class="headerlink" title="运行的容器名称"></a>运行的容器名称</h4><p>redis容器，yct_redis,做数据缓存</p><p>proxy容器，yct_proxy,做代理服务</p><p>worker容器，worker_c 做数据缓存到redis中，worker_a 做数据解析 ，worker_s 做数据存库到mysql</p><p>aliyun_worker容器，to_save 处理阿里云代理的数据存到本地数据库</p><h5 id="连接RabbitMQ的地址-yct"><a href="#连接RabbitMQ的地址-yct" class="headerlink" title="连接RabbitMQ的地址 yct"></a>连接RabbitMQ的地址 yct</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_HOST = <span class="string">'47.102.218.137'</span></span><br><span class="line">RABBITMQ_PORT = <span class="number">5672</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://cic_admin:JYcxys@3030@&#123;&#125;:&#123;&#125;/yct'</span>.format(RABBITMQ_HOST,RABBITMQ_PORT)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bee85252f246        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">new_proxy:</span>latest                <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">5</span> hours ago         Up <span class="number">5</span> hours                  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8888</span>-&gt;<span class="number">8080</span>/tcp             yct_proxy</span><br><span class="line"><span class="number">30</span>a27b1a1504        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">yct_worker:</span>latest               <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">2</span> days ago          Up <span class="number">2</span> days                                                      worker_s</span><br><span class="line">feff1b804441        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">yct_worker:</span>latest               <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">2</span> days ago          Up <span class="number">2</span> days                                                      worker_a</span><br><span class="line"><span class="number">937</span>bda5c14b7        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">yct_worker:</span>latest               <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">2</span> days ago          Up <span class="number">2</span> days                                                      worker_c</span><br><span class="line">b461871a137b        docker.io<span class="regexp">/redis                                      "docker-entrypoint..."   2 weeks ago         Up 2 weeks                  6379/</span>tcp                           yct_redis</span><br><span class="line"><span class="number">666</span>ead4ef827        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">aliyun_yct_worker:</span>latest        <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">4</span> days ago          Up <span class="number">4</span> days                                                      to_save</span><br></pre></td></tr></table></figure><hr><h3 id="阿里云服务器-newprocy-yuanqu01"><a href="#阿里云服务器-newprocy-yuanqu01" class="headerlink" title="阿里云服务器 newprocy-yuanqu01"></a>阿里云服务器 newprocy-yuanqu01</h3><h4 id="部署容器地址"><a href="#部署容器地址" class="headerlink" title="部署容器地址"></a>部署容器地址</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@<span class="keyword">47</span>.<span class="keyword">103</span>.<span class="keyword">197</span>.<span class="keyword">163</span></span><br></pre></td></tr></table></figure><h4 id="运行容器名称"><a href="#运行容器名称" class="headerlink" title="运行容器名称"></a>运行容器名称</h4><p>redis容器，yct_redis,做数据缓存</p><p>proxy容器，yct_proxy,做代理服务</p><p>worker容器，to_create 做数据缓存到redis中，to_analysis 做数据解析解析出需要的字段，将解析后的数据作为参数传递到to_save消息队列，供本地的服务器的to_save容器存库</p><h5 id="连接RabbitMQ的地址-newprocy-yuanqu01"><a href="#连接RabbitMQ的地址-newprocy-yuanqu01" class="headerlink" title="连接RabbitMQ的地址 newprocy-yuanqu01"></a>连接RabbitMQ的地址 newprocy-yuanqu01</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_HOST = <span class="string">'47.102.218.137'</span></span><br><span class="line">RABBITMQ_PORT = <span class="number">5672</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://cic_admin:JYcxys@3030@&#123;&#125;:&#123;&#125;/newprocy-yuanqu01'</span>.format(RABBITMQ_HOST,RABBITMQ_PORT)</span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@newprocy-yuanqu01 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">0cf0c9952b4b        daocloud.io/huhuhuhu/yct_white_list:latest           <span class="string">"/bin/sh -c 'nginx -…"</span>   <span class="number">3</span> days ago          <span class="meta">Up</span> <span class="number">3</span> days           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">9999</span>-&gt;<span class="number">6666</span>/tcp   white_list</span><br><span class="line">5251bcc0e7d6        daocloud.io/huhuhuhu/aliyun_yct_worker:latest        <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">4</span> days ago          <span class="meta">Up</span> <span class="number">4</span> days                                    to_analysis</span><br><span class="line">d5542e638405        daocloud.io/huhuhuhu/aliyun_yct_worker:latest        <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">4</span> days ago          <span class="meta">Up</span> <span class="number">4</span> days                                    to_create</span><br><span class="line">44f9d01fb72a        daocloud.io/huhuhuhu/aliyun01_proxy:aliyun-c0ecb62   <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">4</span> days ago          <span class="meta">Up</span> <span class="number">4</span> days           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">8888</span>-&gt;<span class="number">8080</span>/tcp   yct_proxy</span><br><span class="line">15df20e8da42        redis:<span class="number">3.2</span><span class="meta">.12</span>                                         <span class="string">"docker-entrypoint.s…"</span>   <span class="number">2</span> weeks ago         <span class="meta">Up</span> <span class="number">6</span> days           <span class="number">6379</span>/tcp                 yct_redis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker(link)容器互联</title>
      <link href="/2019/05/28/Docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
      <url>/2019/05/28/Docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于业务需要，需要将现有的服务迁移到阿里云上，该服务使用容器运行，外部需要连接一个redis进行暂存数据；<br>所以使用另一个容器运行一个redis，本文就是关于现有容器服务互联到另外一个redis容器，其他数据库mysql等也是类似的做法。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>CentOS 7.6</p><h3 id="下载redis镜像"><a href="#下载redis镜像" class="headerlink" title="下载redis镜像"></a>下载redis镜像</h3><p>在 DockerHub <a href="https://hub.docker.com/_/redis" target="_blank" rel="noopener">https://hub.docker.com/_/redis</a><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker pull redis</span></span><br></pre></td></tr></table></figure></p><h3 id="运行redis镜像"><a href="#运行redis镜像" class="headerlink" title="运行redis镜像"></a>运行redis镜像</h3><p>由于是容器之间的互联，所以就不做端口映射，redis容器默认运行在6379端口<br>启动命令如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name <span class="string">[redis容器名称]</span> -d <span class="string">[镜像名]</span></span><br></pre></td></tr></table></figure></p><h3 id="修改服务中的redis的连接地址"><a href="#修改服务中的redis的连接地址" class="headerlink" title="修改服务中的redis的连接地址"></a>修改服务中的redis的连接地址</h3><p>修改我的已有服务配置文件中的redis地址<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbex0r1u6sj30du028dfv.jpg" alt></p><h3 id="使用–link参数连接redis"><a href="#使用–link参数连接redis" class="headerlink" title="使用–link参数连接redis"></a>使用–link参数连接redis</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">--name</span> <span class="selector-tag">test_proxy</span> <span class="selector-tag">--link</span> <span class="selector-attr">[redis容器名称]</span><span class="selector-pseudo">:aliyun_redis</span> <span class="selector-tag">-p</span> 8888<span class="selector-pseudo">:8080</span> <span class="selector-tag">-d</span> <span class="selector-attr">[服务镜像]</span></span><br></pre></td></tr></table></figure><p>其中 –link 后面冒号左右两边分别代表 已在运行的redis容器名称或id 和 服务里的redis地址名称；<br>直接将正在运行的redis服务映射到服务里面的redis地址.</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记--关于mitmproxy的代理连接被重置的问题</title>
      <link href="/2019/05/27/%E5%B0%8F%E8%AE%B0-%E5%85%B3%E4%BA%8Emitmproxy%E7%9A%84%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5%E8%A2%AB%E9%87%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/27/%E5%B0%8F%E8%AE%B0-%E5%85%B3%E4%BA%8Emitmproxy%E7%9A%84%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5%E8%A2%AB%E9%87%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在浏览器设置proxy的代理之后，访问网页显示连接被重置，然后查看日志，报错信息如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@procy ~]# docker logs test_proxy</span><br><span class="line">Loading script /code/start_script.py</span><br><span class="line">Proxy server listening <span class="meta">at</span> http://*:<span class="number">8080</span></span><br><span class="line"><span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span>:<span class="number">58074</span>: clientconnect</span><br><span class="line">Client connection from ::ffff:<span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span> killed by block_global</span><br><span class="line"><span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span>:<span class="number">58074</span>: Connection killed</span><br><span class="line"><span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span>:<span class="number">58074</span>: clientdisconnect</span><br></pre></td></tr></table></figure><p>可以看到 ‘killed by block_global’ 连接被kill掉</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>去官网找到<a href="https://discourse.mitmproxy.org/t/connection-killed-by-block-global-when-trying-to-connect-remotely/1215" target="_blank" rel="noopener">解决办法</a></p><p>启动参数 添加 –set block_global=false 将block_global设为false</p><p>试了一下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump --<span class="builtin-name">set</span> <span class="attribute">block_global</span>=<span class="literal">false</span> -s /code/start_script.py</span><br></pre></td></tr></table></figure></p><p>-s 参数是使用启动脚本进行启动</p><p>又恢复正常，至于原因不是很清楚，因为之前一直运行很正常，可能是跟网络有关。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mitmproxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中运行mitiproxy+celery</title>
      <link href="/2019/05/24/Docker%E4%B8%AD%E8%BF%90%E8%A1%8Cmitiproxy-celery/"/>
      <url>/2019/05/24/Docker%E4%B8%AD%E8%BF%90%E8%A1%8Cmitiproxy-celery/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文只是关于在docker中运行mitmproxy和celery的过程；</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>使用mitmproxy做中间人代理获取网站的请求和响应，以及使用<br>celery worker 对截取的请求进行过滤解析后存库</p><h5 id="使用docker的原因"><a href="#使用docker的原因" class="headerlink" title="使用docker的原因"></a>使用docker的原因</h5><p>1.最初的本地开发环境是Windows系统，由于celery的某些版本对Windows不支持，所以会出现不兼容的问题，最后找到celery==4.3.0rc1版本，同时安装mitmproxy和celery成功.<br>2.当我在服务器(ubuntu16.04)上使用虚拟环境安装环境依赖的时候，安装mitmproxy一直安装失败，好像是关于系统编译的一些报错，mitmproxy只支持python3.6以上版本，查询无果，最后放弃。</p><p>使用docker最主要的就是隔离性，轻量化，版本控制，迁移比较方便</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>mitmproxy==4.0.4</p><p>celery==4.3.0rc1</p><h3 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h3><p>分别打包两个镜像，一个镜像运行proxy容器，一个镜像运行celery的worker</p><blockquote><p>关于dockerfile的语法,参考<a href="https://www.cnblogs.com/lienhua34/p/5170335.html" target="_blank" rel="noopener">https://www.cnblogs.com/lienhua34/p/5170335.html</a></p></blockquote><h4 id="proxy镜像"><a href="#proxy镜像" class="headerlink" title="proxy镜像"></a>proxy镜像</h4><p>首先创建Dockerfile文件，没有后缀，注意文件名首字母D大写，因为踩过坑</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span> </span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> requirements.txt /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libfontconfig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /code/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>使用EXPOSE命令将容器的运行端口8080暴露出来<br>使用CMD命令运行docker-entrypoint.sh启动文件，内容如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/mi</span>tmdump -s <span class="regexp">/code/</span>start_script.py</span><br></pre></td></tr></table></figure><p>如果不加 /usr/local/bin/ 路径会找不到 mitmdump</p><h5 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h5><p>我使用的是daocloud平台打包镜像，比较方便，关联GitHub仓库就可以直接打包，有新的提交就会自动重新打包一个版本</p><p>执行日志<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewvpmgx9j31o00u00zr.jpg" alt="执行日志"><br>打包的项目<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewwct95xj31us0q2wje.jpg" alt="打包记录"><br>拉取打包好的镜像<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="string">[镜像]</span></span><br></pre></td></tr></table></figure></p><p>启动容器<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery <span class="built_in">run</span> <span class="comment">--name my_proxy -p 8888:8080 -d &lt;镜像名称&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用 -p 参数进行端口映射，将容器暴露的8080端口映射到宿主机的8888端口</p><p>查看运行状态,是否正常启动<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@procy</span> ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">b5af5afc3d74        <span class="symbol">daocloud.io...:</span>latest   <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">3</span> seconds ago       Up <span class="number">3</span> seconds        <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:</span><span class="number">8888</span>-&gt;<span class="number">8080</span>/tcp   my_proxy</span><br></pre></td></tr></table></figure></p><p>看到status为up，并且已经映射到8888端口</p><p>查看日志,容器内部监听8080端口<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@procy ~]<span class="comment"># docker logs my_proxy</span></span><br><span class="line">Loading script <span class="regexp">/code/</span>start_script.py</span><br><span class="line">Proxy server listening at http:<span class="regexp">//</span>*:<span class="number">8080</span></span><br></pre></td></tr></table></figure></p><h4 id="代理运行成功后设置代理"><a href="#代理运行成功后设置代理" class="headerlink" title="代理运行成功后设置代理"></a>代理运行成功后设置代理</h4><p>在浏览器中设置代理地址，一般使用火狐，设置代理地址为服务的地址，在8888端口<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewwxvommj31gb0u04a3.jpg" alt></p><p>随便打开一个网页，可以看到请求地址为所设置的代理地址<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewxesqj7j31gb0u0e43.jpg" alt></p><p>使用 docker logs my_proxy<br>看到日志的输出一大堆，找到你访问的那一条URL就说明代理成功了<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">180.165</span><span class="number">.231</span><span class="number">.56</span>:<span class="number">57424</span>: GET http:<span class="comment">//addons.g-fox.cn/ntab.gif?c=ntab&amp;t=timing&amp;a=1-o-idb&amp;d=73&amp;f=&amp;r=0.8194234211953002&amp;cid=firefox.com.cn</span></span><br><span class="line">                   <span class="params">&lt;&lt; <span class="number">200</span> OK <span class="number">800</span>b</span></span><br><span class="line"><span class="params"><span class="number">180.165</span><span class="number">.231</span><span class="number">.56</span>:<span class="number">57426</span>: GET http://addons.g-fox.cn/ntab.gif?c=ntab<span class="variable">&amp;t</span>=timing<span class="variable">&amp;a</span>=<span class="number">1</span>-o-cursor<span class="variable">&amp;d</span>=<span class="number">80</span><span class="variable">&amp;f</span>=<span class="variable">&amp;r</span>=<span class="number">0.9766453266846722</span><span class="variable">&amp;cid</span>=firefox.com.cn</span></span><br><span class="line"><span class="params">                   &lt;&lt; <span class="number">200</span> OK <span class="number">800</span>b</span></span><br></pre></td></tr></table></figure></p><h4 id="celery镜像"><a href="#celery镜像" class="headerlink" title="celery镜像"></a>celery镜像</h4><p>环境依赖与proxy镜像的相同，只是运行的启动命令不同；<br>因为这里的数据解析任务我是分为三个队列去执行，这样异步执行可以减少数据处理的时间，相互独立，失败的任务不会影响到其他的任务<br>1.第一个队列create里的任务只是简单的将mitmproxy传递过来的原始pickle后的请求以及响应的对象暂存到redis中，并设置过期时间，然后异步调用analysis队列<br>2.第二个队列analysis里的任务是解析pickle前的request对象和response对象，获取需要的内容，再异步调用save队列<br>3.第三个队列save主要是将解析后的数据更新到mysql中，以供页面回显。</p><p>celery Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> requirements.txt /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libfontconfig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> C_QUEUE to_create</span><br><span class="line"><span class="keyword">ENV</span> A_QUEUE to_analysis</span><br><span class="line"><span class="keyword">ENV</span> S_QUEUE to_save</span><br><span class="line"><span class="keyword">ENV</span> QUEUE to_create</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /code/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>docker-entrypoint.sh执行文件内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$QUEUE</span>"</span> = <span class="string">"<span class="variable">$C_QUEUE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">celery -A handle_data.celery_app worker -l info -Q to_create --uid 13</span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$QUEUE</span>"</span> = <span class="string">"<span class="variable">$A_QUEUE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">celery -A handle_data.celery_app worker -l info -Q to_analysis --uid 13</span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$QUEUE</span>"</span> = <span class="string">"<span class="variable">$S_QUEUE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">celery -A handle_data.celery_app worker -l info -Q to_save --uid 13</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>dockerfile中的 ENV 指定环境变量,通过.sh文件判断启动命令里的参数，to_create,to_analysis,to_save 三个队列，指定到不同的消息队列</p><p>启动命令是<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name to_create --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_create -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --name to_analysis --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_analysis -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --name to_save --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_save -d [镜像名称]</span><br></pre></td></tr></table></figure></p><p>–name 启动容器名称</p><p>–link 是关联redis容器，作为数据缓存</p><p>-e 参数后面 指定 QUEUE 为 to_create 队列</p><p>-d 守护进程运行</p><p>启动三个容器，进行数据解析和存库</p><h3 id="迁移到阿里云"><a href="#迁移到阿里云" class="headerlink" title="迁移到阿里云"></a>迁移到阿里云</h3><p>由于客户量增多，需要将服务从我们的服务器扩展到阿里云上, 由于解析后的数据需要放到自己本地的数据库里；</p><p>1.在RabbitMQ上新建一个vhost,存放阿里云代理扔出的任务消息,此处是 newproxy-yuanqu01；</p><p>RabbitMQ是运行阿里云上的另一台服务器，地址为 47.102.218.137:5672<br><img src="https://tva1.sinaimg.cn/large/006tNbRwly1gbewy4paj0j31j50u0dp2.jpg" alt></p><p>2.先运行proxy代理，关联到docker redis 容器<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">--name</span> <span class="selector-tag">yct_proxy</span> <span class="selector-tag">--link</span> <span class="selector-tag">yct_redis</span><span class="selector-pseudo">:aliyun_redis</span> <span class="selector-tag">-p</span> 8888<span class="selector-pseudo">:8080</span> <span class="selector-tag">-d</span> <span class="selector-attr">[镜像名称]</span></span><br></pre></td></tr></table></figure></p><p>3.运行celery worker，读取到rabbitMQ中的任务消息去执行,进行数据截取，解析<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name to_create --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_create -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --name to_analysis --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_analysis -d [镜像名称]</span><br></pre></td></tr></table></figure></p><p>4.由于解析后的数据是要存到我们自己的服务器数据库中，所以就要将数据存储的服务部署到自己的服务器上<br>使用同样的yct_worker镜像，连接到阿里云的RabbitMQ，订阅to_save消息队列里的内容，将数据存储到正式环境数据库中<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name to_save --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_save -d [镜像名称]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> celery </tag>
            
            <tag> mitmproxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中的环境参数(个人使用)</title>
      <link href="/2019/04/20/workfile/"/>
      <url>/2019/04/20/workfile/</url>
      
        <content type="html"><![CDATA[<p><strong><em>服务器</em></strong></p><hr><p>ssh <a href="mailto:python@192.168.1.150" target="_blank" rel="noopener">python@192.168.1.150</a> ,     JYcxys@3030</p><p><strong><em>mysql地址</em></strong></p><hr><p>192.168.1.170:3306  连接串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mysql+pymysql://cic_admin:TaBoq,,1234@192.168.1.170:3306/cicjust_splinter?charset=utf8&amp;autocommit=true"</span></span><br></pre></td></tr></table></figure><p>192.168.10.11:3306 连接串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mysql+pymysql://cic_admin:159357a@&#123;&#125;:&#123;&#125;/cic_splinter?charset=utf8&amp;autocommit=true"</span></span><br></pre></td></tr></table></figure><p>Mysql 远程连接</p><p>mysql -u 用户名 -p密码 -h IP地址 -P 端口号 -D 数据库名字 </p><hr><p><strong>celery配置</strong></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_HOST = <span class="string">'192.168.1.152'</span></span><br><span class="line">RABBITMQ_PORT = <span class="number">5672</span></span><br><span class="line"></span><br><span class="line">RABBITMQ_USER = <span class="string">'rabbitmq'</span></span><br><span class="line">RABBITMQ_PWD = <span class="string">'JYcxys@3030'</span></span><br><span class="line"></span><br><span class="line">REDIS_HOST = <span class="string">"192.168.1.152"</span></span><br><span class="line">REDIS_PORT = <span class="number">16379</span></span><br><span class="line"></span><br><span class="line">CELERY_BROKER_URL = <span class="string">'amqp://&#123;0&#125;:&#123;1&#125;@&#123;2&#125;:&#123;3&#125;/myvhost'</span>\</span><br><span class="line">    .format(RABBITMQ_USER,RABBITMQ_PWD,RABBITMQ_HOST,RABBITMQ_PORT)</span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://&#123;0&#125;:&#123;1&#125;/15'</span>.format(REDIS_HOST,REDIS_PORT)</span><br></pre></td></tr></table></figure><p><strong><em>celery命令</em></strong></p><p>1.守护进程启动方式(start/stop/restart)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery multi start export_for_in -A celery_tasks.celery_app -l info --logfile=./celerylog.log</span><br></pre></td></tr></table></figure><p>2.开启flower后台监控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">celery.exe flower --broker=amqp://guest:guest@localhost:5672/test</span><br><span class="line">celery.exe flower -broker=amqp://cic_admin:JYcxys@3030@192.168.1.152:5672/yct</span><br></pre></td></tr></table></figure><p><strong><em>rabbitmq的安装与配置</em></strong></p><p><em>Windows安装rabbitmq</em></p><p><strong><em>docker命令</em></strong></p><hr><ol><li><p>启动chrome镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name chrome_for_yzf -p 5902:5900 -p 4442:4444 selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure></li><li><p>下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure><p>说明：standalone-chrome-debug 镜像是带有vnc server </p></li><li><p>运行容器(–name后为容器的名称,-d 守护进程运行,-p 由容器露出的8080端口,映射到宿主机的8081端口)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name your_app_name -p 8081:8080 -d selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure></li><li><p>使用docker MySQL</p><ol><li><p>拉取mysql镜像 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li><li><p>运行MySQL容器 dockers(MYSQL_ROOT_PASSWORD=后为数据库定义密码用户名为root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql_service -e MYSQL_ROOT_PASSWORD=your_pwd -d daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li><li><p>使用其他的docker容器连接docker的MySQL服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some_app --link your_mysql_name:mysql -p 8080:8080 -d daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li><li><p>将MySQL容器内的数据持久化到宿主机上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql --privileged=true -v /home/docker_mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=cicjust_proxy -d daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下安装python3</title>
      <link href="/2019/03/01/ubuntu%E4%B8%8Bpython3%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/03/01/ubuntu%E4%B8%8Bpython3%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ubuntu系统自带python2.7，不同的版本的ubuntu所带的python3的版本也有所不同，我现在使用的这台是python3.5;由于需要的服务只支持python3.6以上版本，所以本文以安装python3.7为例</p><h4 id="服务器运行环境："><a href="#服务器运行环境：" class="headerlink" title="服务器运行环境："></a>服务器运行环境：</h4><pre><code>ubuntu18.04</code></pre><h4 id="安装方式简介"><a href="#安装方式简介" class="headerlink" title="安装方式简介:"></a>安装方式简介:</h4><pre><code>不影响已有的python其他版本环境增量式安装完全隔离的沙箱环境</code></pre><h3 id="基本环境-便于后面的编译成功"><a href="#基本环境-便于后面的编译成功" class="headerlink" title="基本环境(便于后面的编译成功)"></a>基本环境(便于后面的编译成功)</h3><p>中间可能有多余空格，去除下再运行，一般都能安装成功，如果不能可以先更新下sudo apt-get update</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install zlib1g-<span class="built_in">dev</span> libbz2-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span> libncurses5-<span class="built_in">dev</span> libsqlite3-<span class="built_in">dev</span> </span><br><span class="line">libreadline-<span class="built_in">dev</span> tk-<span class="built_in">dev</span> libgdbm-<span class="built_in">dev</span> libdb-<span class="built_in">dev</span> libpcap-<span class="built_in">dev</span> xz-utils libexpat1-<span class="built_in">dev</span> </span><br><span class="line">liblzma-<span class="built_in">dev</span> libffi-<span class="built_in">dev</span> libc6-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在python官网下载指定平台下的python3.7.1的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz</span><br></pre></td></tr></table></figure><p>下载完成后，所在目录下会有 Python-3.7.1.tgz 的文件</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>进行解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf Python-3.7.1.tgz</span><br></pre></td></tr></table></figure><p>所在目录下会有 Python-3.7.1 的文件夹</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>进入文件夹Python-3.7.1,进行配置</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> Python-3.7.1</span><br><span class="line"><span class="string">./configure</span> <span class="params">--with-ssl</span> <span class="params">--prefix=/usr/local/python3</span></span><br></pre></td></tr></table></figure><p>编译、安装</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><blockquote><p>执行后可能会报错，请参考<a href="https://blog.csdn.net/jpch89/article/details/81813267" target="_blank" rel="noopener">https://blog.csdn.net/jpch89/article/details/81813267</a></p></blockquote><h3 id="删除软链"><a href="#删除软链" class="headerlink" title="删除软链"></a>删除软链</h3><p>先执行查看版本，如果有则证明软连接已经存在，先将其删除再重新建立</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">python3</span> <span class="selector-tag">-V</span></span><br><span class="line"><span class="selector-tag">Python</span> 3<span class="selector-class">.5</span><span class="selector-class">.2</span></span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip3 -V</span></span><br><span class="line">The program <span class="string">'pip3'</span> <span class="keyword">is</span> currently <span class="keyword">not</span> installed. You can install <span class="literal">it</span> <span class="keyword">by</span> typing:apt install python3-pip</span><br></pre></td></tr></table></figure><p>可见我的机器上的默认的python3的版本为3.5，pip3没有安装</p><p>删除软链</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># rm -rf /usr/bin/python3</span></span><br><span class="line"><span class="meta"># rm -rf /usr/bin/pip3</span></span><br></pre></td></tr></table></figure><h3 id="建立新的指向python3-7的软链"><a href="#建立新的指向python3-7的软链" class="headerlink" title="建立新的指向python3.7的软链"></a>建立新的指向python3.7的软链</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加python3的软链接</span></span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/python3/</span>bin<span class="regexp">/python3.7 /u</span>sr<span class="regexp">/bin/</span>python3</span><br><span class="line"><span class="comment">#添加 pip3 的软链接</span></span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/python3/</span>bin<span class="regexp">/pip3.7 /u</span>sr<span class="regexp">/bin/</span>pip3</span><br></pre></td></tr></table></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python3 -V</span><br><span class="line">Python 3.7.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pip3 -V</span><br><span class="line">pip 10.0.1 from /usr/local/python3/lib/python3.7/site-packages/pip (python 3.7)</span><br></pre></td></tr></table></figure><p>至此安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记--阿里云pip配置虚拟环境报错</title>
      <link href="/2019/03/01/%E5%B0%8F%E8%AE%B0--%E9%98%BF%E9%87%8C%E4%BA%91pip%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99/"/>
      <url>/2019/03/01/%E5%B0%8F%E8%AE%B0--%E9%98%BF%E9%87%8C%E4%BA%91pip%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>今天在阿里云上使用pip3安装虚拟环境的时候，出现了一个错误locale.Error: unsupported locale setting</p><p>不支持语言环境，报错如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@iZuf6eh47kp5ew16h2mywqZ:~<span class="comment"># sudo pip3 install virtualenv</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/bin/pip3"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sys.<span class="keyword">exit</span>(main())</span><br><span class="line">  File <span class="string">"/usr/lib/python3/dist-packages/pip/__init__.py"</span>, line <span class="number">215</span>, <span class="keyword">in</span> main</span><br><span class="line">    locale.setlocale(locale.LC_ALL, <span class="string">''</span>)</span><br><span class="line">  File <span class="string">"/usr/lib/python3.5/locale.py"</span>, line <span class="number">594</span>, <span class="keyword">in</span> setlocale</span><br><span class="line">    return _setlocale(category, locale)</span><br><span class="line">locale.Error: unsupported locale setting</span><br></pre></td></tr></table></figure><p>解决办法很简单，设置语言就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LC_ALL=&quot;en_US.UTF-8&quot;</span><br><span class="line">export LC_CTYPE=&quot;en_US.UTF-8&quot;</span><br></pre></td></tr></table></figure><p>执行上面这两句就OK了，后面就可以继续pip安装了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
