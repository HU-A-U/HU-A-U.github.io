<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>nginx+uwsgi+flask/django部署web服务</title>
      <link href="/2019/06/18/nginx-uwsgi-flask-django%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1/"/>
      <url>/2019/06/18/nginx-uwsgi-flask-django%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>使用nginx+uwsgi+flask 部署web服务</p><h4 id="一、放置项目文件"><a href="#一、放置项目文件" class="headerlink" title="一、放置项目文件"></a>一、放置项目文件</h4><p>将项目文件夹放到服务器上</p><p>1.ssh 远程连接服务器,登陆密码 JYcxys@3030<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">python</span>@<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">1</span>.<span class="keyword">150</span></span><br></pre></td></tr></table></figure></p><p>2.使用 scp 将本地项目文件放到服务器上的 /home/python/workspace 工作目录下<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /Users/hu-a-u/MyCode/work/yct_worker python<span class="variable">@192</span>.<span class="number">168.1</span>.<span class="number">150</span><span class="symbol">:/home/python/workspace</span></span><br></pre></td></tr></table></figure></p><p>如果是文件夹需要带上 -r 参数</p><h4 id="二、编写uwsgi的-ini文件（一般需要sudo）"><a href="#二、编写uwsgi的-ini文件（一般需要sudo）" class="headerlink" title="二、编写uwsgi的.ini文件（一般需要sudo）"></a>二、编写uwsgi的.ini文件（一般需要sudo）</h4><p>.ini 文件用于运行服务，<br>在服务器的 /etc/nginx 目录下创建一个ini文件<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">nano</span> <span class="selector-tag">demo</span><span class="selector-class">.ini</span></span><br></pre></td></tr></table></figure></p><p>内容如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">chdir</span> = /home/python/workspace/demo #项目文件夹</span><br><span class="line"><span class="attr">wsgi-file</span> = /home/python/workspace/demo/manage.py #项目启动py文件</span><br><span class="line"><span class="attr">home</span> = /home/python/.virtualenvs/py3_flask/ #项目运行的虚拟环境</span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">socket</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">5002</span> #运行在一个端口</span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">enable-threads</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="attr">daemonize</span> = %(chdir)/uwsgi.log #uwsig的日志文件</span><br><span class="line"><span class="attr">stats</span>=%(chdir)/export_flask_uwsgi_out.status #运行状态文件</span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/export_flask_uwsgi_out.pid #记录运行的进程号，便于重启uwsgi服务</span><br><span class="line"><span class="attr">callable</span> = app</span><br></pre></td></tr></table></figure></p><p>django项目<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[uwsgi]</span></span><br><span class="line"><span class="attr">chdir</span> = /home/python/workspace/cicjust_TaxSb/</span><br><span class="line"><span class="attr">wsgi-file</span> = /home/python/workspace/cicjust_TaxSb/confg/wsgi.py</span><br><span class="line"><span class="attr">home</span> = /home/python/.virtualenvs/django_py3/</span><br><span class="line"><span class="attr">master</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">processes</span> = <span class="number">2</span></span><br><span class="line"><span class="attr">socket</span> =<span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br><span class="line"><span class="attr">vacuum</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">buffer-size</span> = <span class="number">65536</span></span><br><span class="line"><span class="attr">daemonize</span> = %(chdir)/uwsgi.log</span><br><span class="line"><span class="attr">stats</span>=%(chdir)/uwsgi.status</span><br><span class="line"><span class="attr">pidfile</span>=%(chdir)/uwsgi.pid</span><br></pre></td></tr></table></figure></p><p>chdir 是项目的文件夹路径</p><p>wsgi-file 是项目运行的py文件</p><p>home 是项目运行的环境依赖，虚拟环境</p><p>socket 运行在服务器地址</p><p>daemonize 记录日志</p><p>callable 指出的是具体执行.run方法的那个实体的名字，一般而言都是’app=Flask(<strong>name</strong>)’所以这里是app</p><h4 id="三、启动uwsgi"><a href="#三、启动uwsgi" class="headerlink" title="三、启动uwsgi"></a>三、启动uwsgi</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uwsgi <span class="params">--ini</span> <span class="string">/etc/nginx/demo.ini</span></span><br></pre></td></tr></table></figure><p>一般不需要加sudo，启动后监听端口5002是否已经在运行，使用 netstat -lntp 命令<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ netstat -lntp</span><br><span class="line">Proto Recv-Q Send-Q Local<span class="built_in"> Address </span>          Foreign<span class="built_in"> Address </span>        State       PID/Program name</span><br><span class="line">tcp        0      0 127.0.0.1:5002          0.0.0.0:*               LISTEN      3603/uwsgi</span><br></pre></td></tr></table></figure></p><h4 id="四、配置nginx并启动"><a href="#四、配置nginx并启动" class="headerlink" title="四、配置nginx并启动"></a>四、配置nginx并启动</h4><p>nginx的配置在 /etc/nginx/sites-available<br>切换到目录下，sudo创建一个文件没有后缀</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo nano demo</span></span><br></pre></td></tr></table></figure><p>配置内容如下:<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        listen 6600 ; //默认的web访问端口</span><br><span class="line">        <span class="attribute">listen</span> [::]:<span class="number">6600</span> ; </span><br><span class="line"></span><br><span class="line">        server_name 116.228.88.888; //对外访问的地址，也可以是域名</span><br><span class="line">        </span><br><span class="line">        <span class="attribute">index</span> index.html index.htm index.nginx-debian.html;</span><br><span class="line">        <span class="attribute">location</span> /static &#123;</span><br><span class="line">               alias /home/python/workspace/demo/static; //静态文件的目录</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> /  &#123;</span><br><span class="line">               uwsgi_pass 127.0.0.1:5002;  //需要和uwsgi的配置文件里socket项的地址相同,否则无法让uwsgi接收到请求。</span><br><span class="line">               include /etc/nginx/uwsgi_params; //这里是导入的uwsgi配置</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>文件创建完成之后，创建软链到 /etc/nginx/sites-enabled 目录下，命令<br>ln -s [源文件全路径] [目标文件全路径]<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-available/</span>demo <span class="regexp">/etc/</span>nginx<span class="regexp">/sites-enabled/</span>demo</span><br></pre></td></tr></table></figure></p><p>这样配置完后，需要重启nginx服务<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo nginx -s reload</span></span><br></pre></td></tr></table></figure></p><p>当外部有一个6600端口的请求送到本机时，先让nginx开始处理。<br>nginx进行一些处理之后转发给这里配置的uwsgi_pass地址，刚好传送给uwsgi处理。<br>再由uwsgi来调用项目中的代码处理请求返回。</p><h4 id="五、注意"><a href="#五、注意" class="headerlink" title="五、注意"></a>五、注意</h4><p>服务都运行正常后，用浏览器访问不了，检查防火墙是否开启6600这个端口</p><p>查看防火墙状态<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ sudo firewall-cmd --state</span><br><span class="line">running</span><br></pre></td></tr></table></figure></p><p>说明防火墙已开启</p><p>查看已开放的端口<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python<span class="meta">@python</span>-<span class="string">splinter:</span>/$ sudo firewall-cmd --list-ports</span><br><span class="line"><span class="number">5000</span><span class="regexp">/tcp 5002/</span>tcp <span class="number">5500</span><span class="regexp">/tcp 5005/</span>tcp <span class="number">5006</span><span class="regexp">/tcp 8000/</span>tcp <span class="number">5008</span><span class="regexp">/tcp 12233/</span>tcp</span><br></pre></td></tr></table></figure></p><p>可以看到没有6600端口，然后防火墙开启6600端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ sudo firewall-cmd --zone=public --add-port=6600/tcp --permanent</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>开启成功后需要重启防火墙<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python@python-splinter:/$ sudo firewall-cmd --reload</span><br><span class="line">success</span><br></pre></td></tr></table></figure></p><p>然后使用浏览器访问成功</p>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> uwsgi </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> uwsgi </tag>
            
            <tag> flask </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>celery开启flower后台监控任务执行状态(docker)</title>
      <link href="/2019/06/17/celery%E5%BC%80%E5%90%AFflower%E5%90%8E%E5%8F%B0%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81/"/>
      <url>/2019/06/17/celery%E5%BC%80%E5%90%AFflower%E5%90%8E%E5%8F%B0%E7%9B%91%E6%8E%A7%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E7%8A%B6%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="使用flower容器进行worker后台监控"><a href="#使用flower容器进行worker后台监控" class="headerlink" title="使用flower容器进行worker后台监控"></a>使用flower容器进行worker后台监控</h3><p>使用容器，部署在192.168.1.230</p><p>监听本地worker的容器名称 yct_flower,内网访问地址 192.168.1.230:5555<br><img src="yct_flower.png" alt></p><p>监听阿里云worker的容器名称 aliyun01_flower,内网访问地址 192.168.1.230:5559<br><img src="aliyun01_flower.png" alt></p><p>文件夹目录下只有三个有用文件<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── Dockerfile</span><br><span class="line">├── README.md</span><br><span class="line">├── docker-entrypoint.sh</span><br><span class="line">└── requirements.txt</span><br></pre></td></tr></table></figure></p><hr><h4 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h4><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> requirements.txt /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libfontconfig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> BROKER_HOST <span class="number">47.102</span>.<span class="number">218.137</span></span><br><span class="line"><span class="keyword">ENV</span> BROKER_PORT <span class="number">5672</span></span><br><span class="line"><span class="keyword">ENV</span> VIRTUAL_HOST <span class="string">'yct'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5555</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /code/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><hr><h4 id="docker-entrypoint-sh启动文件"><a href="#docker-entrypoint-sh启动文件" class="headerlink" title="docker-entrypoint.sh启动文件"></a>docker-entrypoint.sh启动文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line">celery flower --broker=amqp://cic_admin:JYcxys@3030@<span class="variable">$BROKER_HOST</span>:<span class="variable">$BROKER_PORT</span>/<span class="variable">$VIRTUAL_HOST</span></span><br></pre></td></tr></table></figure><hr><h4 id="requirements-txt"><a href="#requirements-txt" class="headerlink" title="requirements.txt"></a>requirements.txt</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">celery</span>==<span class="number">4.3</span>.<span class="number">0</span>rc1</span><br><span class="line"><span class="attr">flower</span>==<span class="number">0.9</span>.<span class="number">3</span></span><br></pre></td></tr></table></figure><hr><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --env <span class="attribute">BROKER_HOST</span>=47.102.218.137 --env <span class="attribute">BROKER_PORT</span>=5672 --env <span class="attribute">VIRTUAL_HOST</span>=<span class="string">'yct'</span> --name flower -p 5555:5555 -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --env <span class="attribute">BROKER_HOST</span>=47.102.218.137 --env <span class="attribute">BROKER_PORT</span>=5672 --env <span class="attribute">VIRTUAL_HOST</span>=<span class="string">'newproxy-yuanqu01'</span> --name flower -p 5559:5555 -d [镜像名称]</span><br></pre></td></tr></table></figure><p>其中 BROKER_HOST 、BROKER_PORT 和 VIRTUAL_HOST 为环境变量</p><p>BROKER_HOST 、BROKER_PORT 指定消息队列地址和端口</p><p>VIRTUAL_HOST 指定消息队列的的 vhost名称</p><hr><h4 id="镜像地址（此处是我自己的镜像地址，后面可以自己打包）"><a href="#镜像地址（此处是我自己的镜像地址，后面可以自己打包）" class="headerlink" title="镜像地址（此处是我自己的镜像地址，后面可以自己打包）"></a>镜像地址（此处是我自己的镜像地址，后面可以自己打包）</h4><p>daocloud.io/huhuhuhu/flower_docker:latest</p><hr><p>当监控下的任务太多时，重启flower容器，将前面的任务记录清空<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">restart</span> yct_flower</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> celery </tag>
            
            <tag> flower </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yct_proxy和yct_worker的部署地址</title>
      <link href="/2019/06/17/yct-proxy%E5%92%8Cyct-worker%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
      <url>/2019/06/17/yct-proxy%E5%92%8Cyct-worker%E7%9A%84%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="代码地址"><a href="#代码地址" class="headerlink" title="代码地址"></a>代码地址</h3><p>yct_proxy代码:<a href="https://github.com/HU-A-U/my-proxy" target="_blank" rel="noopener">https://github.com/HU-A-U/my-proxy</a></p><p>yct_worker代码:<a href="https://github.com/HU-A-U/yct_worker" target="_blank" rel="noopener">https://github.com/HU-A-U/yct_worker</a></p><p>分支 aliyun 是 部署在阿里云上的服务的代码内容，不需要合并</p><hr><h3 id="阿里云RabbitMQ后台管理地址"><a href="#阿里云RabbitMQ后台管理地址" class="headerlink" title="阿里云RabbitMQ后台管理地址"></a>阿里云RabbitMQ后台管理地址</h3><p><a href="http://47.102.218.137:15672" target="_blank" rel="noopener">http://47.102.218.137:15672</a></p><p>用户名：cic_admin</p><p>密码：JYcxys@3030</p><hr><h3 id="本地服务器-cic-odoo"><a href="#本地服务器-cic-odoo" class="headerlink" title="本地服务器 cic-odoo"></a>本地服务器 cic-odoo</h3><h4 id="服务器地址"><a href="#服务器地址" class="headerlink" title="服务器地址"></a>服务器地址</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@<span class="keyword">192</span>.<span class="keyword">168</span>.<span class="keyword">1</span>.<span class="keyword">230</span></span><br></pre></td></tr></table></figure><h4 id="镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）"><a href="#镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）" class="headerlink" title="镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）"></a>镜像地址（此处为我自己的打包好的镜像地址，最好后面自己重新打包镜像，重新部署一遍）</h4><p>本地服务proxy镜像地址</p><p>daocloud.io/huhuhuhu/new_proxy:latest</p><p>本地服务worker镜像地址</p><h4 id="运行的容器名称"><a href="#运行的容器名称" class="headerlink" title="运行的容器名称"></a>运行的容器名称</h4><p>redis容器，yct_redis,做数据缓存</p><p>proxy容器，yct_proxy,做代理服务</p><p>worker容器，worker_c 做数据缓存到redis中，worker_a 做数据解析 ，worker_s 做数据存库到mysql</p><p>aliyun_worker容器，to_save 处理阿里云代理的数据存到本地数据库</p><h5 id="连接RabbitMQ的地址-yct"><a href="#连接RabbitMQ的地址-yct" class="headerlink" title="连接RabbitMQ的地址 yct"></a>连接RabbitMQ的地址 yct</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_HOST = <span class="string">'47.102.218.137'</span></span><br><span class="line">RABBITMQ_PORT = <span class="number">5672</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://cic_admin:JYcxys@3030@&#123;&#125;:&#123;&#125;/yct'</span>.format(RABBITMQ_HOST,RABBITMQ_PORT)</span><br></pre></td></tr></table></figure><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bee85252f246        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">new_proxy:</span>latest                <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">5</span> hours ago         Up <span class="number">5</span> hours                  <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8888</span>-&gt;<span class="number">8080</span>/tcp             yct_proxy</span><br><span class="line"><span class="number">30</span>a27b1a1504        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">yct_worker:</span>latest               <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">2</span> days ago          Up <span class="number">2</span> days                                                      worker_s</span><br><span class="line">feff1b804441        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">yct_worker:</span>latest               <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">2</span> days ago          Up <span class="number">2</span> days                                                      worker_a</span><br><span class="line"><span class="number">937</span>bda5c14b7        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">yct_worker:</span>latest               <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">2</span> days ago          Up <span class="number">2</span> days                                                      worker_c</span><br><span class="line">b461871a137b        docker.io<span class="regexp">/redis                                      "docker-entrypoint..."   2 weeks ago         Up 2 weeks                  6379/</span>tcp                           yct_redis</span><br><span class="line"><span class="number">666</span>ead4ef827        daocloud.io<span class="regexp">/huhuhuhu/</span><span class="string">aliyun_yct_worker:</span>latest        <span class="string">"/bin/sh -c /code/..."</span>   <span class="number">4</span> days ago          Up <span class="number">4</span> days                                                      to_save</span><br></pre></td></tr></table></figure><hr><h3 id="阿里云服务器-newprocy-yuanqu01"><a href="#阿里云服务器-newprocy-yuanqu01" class="headerlink" title="阿里云服务器 newprocy-yuanqu01"></a>阿里云服务器 newprocy-yuanqu01</h3><h4 id="部署容器地址"><a href="#部署容器地址" class="headerlink" title="部署容器地址"></a>部署容器地址</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">root</span>@<span class="keyword">47</span>.<span class="keyword">103</span>.<span class="keyword">197</span>.<span class="keyword">163</span></span><br></pre></td></tr></table></figure><h4 id="运行容器名称"><a href="#运行容器名称" class="headerlink" title="运行容器名称"></a>运行容器名称</h4><p>redis容器，yct_redis,做数据缓存</p><p>proxy容器，yct_proxy,做代理服务</p><p>worker容器，to_create 做数据缓存到redis中，to_analysis 做数据解析解析出需要的字段，将解析后的数据作为参数传递到to_save消息队列，供本地的服务器的to_save容器存库</p><h5 id="连接RabbitMQ的地址-newprocy-yuanqu01"><a href="#连接RabbitMQ的地址-newprocy-yuanqu01" class="headerlink" title="连接RabbitMQ的地址 newprocy-yuanqu01"></a>连接RabbitMQ的地址 newprocy-yuanqu01</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_HOST = <span class="string">'47.102.218.137'</span></span><br><span class="line">RABBITMQ_PORT = <span class="number">5672</span></span><br><span class="line">BROKER_URL = <span class="string">'amqp://cic_admin:JYcxys@3030@&#123;&#125;:&#123;&#125;/newprocy-yuanqu01'</span>.format(RABBITMQ_HOST,RABBITMQ_PORT)</span><br></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@newprocy-yuanqu01 ~]# docker ps -a</span><br><span class="line">CONTAINER ID        IMAGE                                                COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">0cf0c9952b4b        daocloud.io/huhuhuhu/yct_white_list:latest           <span class="string">"/bin/sh -c 'nginx -…"</span>   <span class="number">3</span> days ago          <span class="meta">Up</span> <span class="number">3</span> days           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">9999</span>-&gt;<span class="number">6666</span>/tcp   white_list</span><br><span class="line">5251bcc0e7d6        daocloud.io/huhuhuhu/aliyun_yct_worker:latest        <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">4</span> days ago          <span class="meta">Up</span> <span class="number">4</span> days                                    to_analysis</span><br><span class="line">d5542e638405        daocloud.io/huhuhuhu/aliyun_yct_worker:latest        <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">4</span> days ago          <span class="meta">Up</span> <span class="number">4</span> days                                    to_create</span><br><span class="line">44f9d01fb72a        daocloud.io/huhuhuhu/aliyun01_proxy:aliyun-c0ecb62   <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">4</span> days ago          <span class="meta">Up</span> <span class="number">4</span> days           <span class="number">0.0</span><span class="meta">.0</span><span class="meta">.0</span>:<span class="number">8888</span>-&gt;<span class="number">8080</span>/tcp   yct_proxy</span><br><span class="line">15df20e8da42        redis:<span class="number">3.2</span><span class="meta">.12</span>                                         <span class="string">"docker-entrypoint.s…"</span>   <span class="number">2</span> weeks ago         <span class="meta">Up</span> <span class="number">6</span> days           <span class="number">6379</span>/tcp                 yct_redis</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习之--link容器互联</title>
      <link href="/2019/05/28/Docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
      <url>/2019/05/28/Docker%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>由于业务需要，需要将现有的服务迁移到阿里云上，该服务使用容器运行，外部需要连接一个redis进行暂存数据；<br>所以使用另一个容器运行一个redis，本文就是关于现有容器服务互联到另外一个redis容器，其他数据库mysql等也是类似的做法。</p><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>CentOS 7.6</p><h3 id="下载redis镜像"><a href="#下载redis镜像" class="headerlink" title="下载redis镜像"></a>下载redis镜像</h3><p>在 DockerHub <a href="https://hub.docker.com/_/redis" target="_blank" rel="noopener">https://hub.docker.com/_/redis</a><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">docker pull redis</span></span><br></pre></td></tr></table></figure></p><h3 id="运行redis镜像"><a href="#运行redis镜像" class="headerlink" title="运行redis镜像"></a>运行redis镜像</h3><p>由于是容器之间的互联，所以就不做端口映射，redis容器默认运行在6379端口<br>启动命令如下：<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name <span class="string">[redis容器名称]</span> -d <span class="string">[镜像名]</span></span><br></pre></td></tr></table></figure></p><h3 id="修改服务中的redis的连接地址"><a href="#修改服务中的redis的连接地址" class="headerlink" title="修改服务中的redis的连接地址"></a>修改服务中的redis的连接地址</h3><p>修改我的已有服务配置文件中的redis地址<br><img src="redis_host.png" alt></p><h3 id="使用–link参数连接redis"><a href="#使用–link参数连接redis" class="headerlink" title="使用–link参数连接redis"></a>使用–link参数连接redis</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">--name</span> <span class="selector-tag">test_proxy</span> <span class="selector-tag">--link</span> <span class="selector-attr">[redis容器名称]</span><span class="selector-pseudo">:aliyun_redis</span> <span class="selector-tag">-p</span> 8888<span class="selector-pseudo">:8080</span> <span class="selector-tag">-d</span> <span class="selector-attr">[服务镜像]</span></span><br></pre></td></tr></table></figure><p>其中 –link 后面冒号左右两边分别代表 已在运行的redis容器名称或id 和 服务里的redis地址名称；<br>直接将正在运行的redis服务映射到服务里面的redis地址.</p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记--关于mitmproxy的代理连接被重置的问题</title>
      <link href="/2019/05/27/%E5%B0%8F%E8%AE%B0-%E5%85%B3%E4%BA%8Emitmproxy%E7%9A%84%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5%E8%A2%AB%E9%87%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/05/27/%E5%B0%8F%E8%AE%B0-%E5%85%B3%E4%BA%8Emitmproxy%E7%9A%84%E4%BB%A3%E7%90%86%E8%BF%9E%E6%8E%A5%E8%A2%AB%E9%87%8D%E7%BD%AE%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在浏览器设置proxy的代理之后，访问网页显示连接被重置，然后查看日志，报错信息如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@procy ~]# docker logs test_proxy</span><br><span class="line">Loading script /code/start_script.py</span><br><span class="line">Proxy server listening <span class="meta">at</span> http://*:<span class="number">8080</span></span><br><span class="line"><span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span>:<span class="number">58074</span>: clientconnect</span><br><span class="line">Client connection from ::ffff:<span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span> killed by block_global</span><br><span class="line"><span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span>:<span class="number">58074</span>: Connection killed</span><br><span class="line"><span class="number">172.104</span><span class="meta">.123</span><span class="meta">.101</span>:<span class="number">58074</span>: clientdisconnect</span><br></pre></td></tr></table></figure><p>可以看到 ‘killed by block_global’ 连接被kill掉</p><h3 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h3><p>去官网找到<a href="https://discourse.mitmproxy.org/t/connection-killed-by-block-global-when-trying-to-connect-remotely/1215" target="_blank" rel="noopener">解决办法</a></p><p>启动参数 添加 –set block_global=false 将block_global设为false</p><p>试了一下<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mitmdump --<span class="builtin-name">set</span> <span class="attribute">block_global</span>=<span class="literal">false</span> -s /code/start_script.py</span><br></pre></td></tr></table></figure></p><p>-s 参数是使用启动脚本进行启动</p><p>又恢复正常，至于原因不是很清楚，因为之前一直运行很正常，可能是跟网络有关。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mitmproxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker中运行mitiproxy+celery</title>
      <link href="/2019/05/24/Docker%E4%B8%AD%E8%BF%90%E8%A1%8Cmitiproxy-celery/"/>
      <url>/2019/05/24/Docker%E4%B8%AD%E8%BF%90%E8%A1%8Cmitiproxy-celery/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文只是关于在docker中运行mitmproxy和celery的过程；</p><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>使用mitmproxy做中间人代理获取网站的请求和响应，以及使用<br>celery worker 对截取的请求进行过滤解析后存库</p><h5 id="使用docker的原因"><a href="#使用docker的原因" class="headerlink" title="使用docker的原因"></a>使用docker的原因</h5><p>1.最初的本地开发环境是Windows系统，由于celery的某些版本对Windows不支持，所以会出现不兼容的问题，最后找到celery==4.3.0rc1版本，同时安装mitmproxy和celery成功.<br>2.当我在服务器(ubuntu16.04)上使用虚拟环境安装环境依赖的时候，安装mitmproxy一直安装失败，好像是关于系统编译的一些报错，mitmproxy只支持python3.6以上版本，查询无果，最后放弃。</p><p>使用docker最主要的就是隔离性，轻量化，版本控制，迁移比较方便</p><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>mitmproxy==4.0.4</p><p>celery==4.3.0rc1</p><h3 id="编写dockerfile"><a href="#编写dockerfile" class="headerlink" title="编写dockerfile"></a>编写dockerfile</h3><p>分别打包两个镜像，一个镜像运行proxy容器，一个镜像运行celery的worker</p><blockquote><p>关于dockerfile的语法,参考<a href="https://www.cnblogs.com/lienhua34/p/5170335.html" target="_blank" rel="noopener">https://www.cnblogs.com/lienhua34/p/5170335.html</a></p></blockquote><h4 id="proxy镜像"><a href="#proxy镜像" class="headerlink" title="proxy镜像"></a>proxy镜像</h4><p>首先创建Dockerfile文件，没有后缀，注意文件名首字母D大写，因为踩过坑</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span> </span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> requirements.txt /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libfontconfig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /code/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>使用EXPOSE命令将容器的运行端口8080暴露出来<br>使用CMD命令运行docker-entrypoint.sh启动文件，内容如下:</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>local<span class="regexp">/bin/mi</span>tmdump -s <span class="regexp">/code/</span>start_script.py</span><br></pre></td></tr></table></figure><p>如果不加 /usr/local/bin/ 路径会找不到 mitmdump</p><h5 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h5><p>我使用的是daocloud平台打包镜像，比较方便，关联GitHub仓库就可以直接打包，有新的提交就会自动重新打包一个版本</p><p>执行日志<br><img src="daocloud_task.png" alt="执行日志"><br>打包的项目<br><img src="daocloud_projects.png" alt="打包记录"><br>拉取打包好的镜像<br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull <span class="string">[镜像]</span></span><br></pre></td></tr></table></figure></p><p>启动容器<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery <span class="built_in">run</span> <span class="comment">--name my_proxy -p 8888:8080 -d &lt;镜像名称&gt;</span></span><br></pre></td></tr></table></figure></p><p>使用 -p 参数进行端口映射，将容器暴露的8080端口映射到宿主机的8888端口</p><p>查看运行状态,是否正常启动<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root<span class="variable">@procy</span> ~]<span class="comment"># docker ps -a</span></span><br><span class="line">CONTAINER ID        IMAGE                   COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">b5af5afc3d74        <span class="symbol">daocloud.io...:</span>latest   <span class="string">"/bin/sh -c /code/do…"</span>   <span class="number">3</span> seconds ago       Up <span class="number">3</span> seconds        <span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">0</span><span class="symbol">:</span><span class="number">8888</span>-&gt;<span class="number">8080</span>/tcp   my_proxy</span><br></pre></td></tr></table></figure></p><p>看到status为up，并且已经映射到8888端口</p><p>查看日志,容器内部监听8080端口<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@procy ~]<span class="comment"># docker logs my_proxy</span></span><br><span class="line">Loading script <span class="regexp">/code/</span>start_script.py</span><br><span class="line">Proxy server listening at http:<span class="regexp">//</span>*:<span class="number">8080</span></span><br></pre></td></tr></table></figure></p><h4 id="代理运行成功后设置代理"><a href="#代理运行成功后设置代理" class="headerlink" title="代理运行成功后设置代理"></a>代理运行成功后设置代理</h4><p>在浏览器中设置代理地址，一般使用火狐，设置代理地址为服务的地址，在8888端口<br><img src="Docker中运行mitiproxy-celery/Firefox_http_proxy.png" alt></p><p>随便打开一个网页，可以看到请求地址为所设置的代理地址<br><img src="Docker中运行mitiproxy-celery/http_proxy_ok.png" alt></p><p>使用 docker logs my_proxy<br>看到日志的输出一大堆，找到你访问的那一条URL就说明代理成功了<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">180.165</span><span class="number">.231</span><span class="number">.56</span>:<span class="number">57424</span>: GET http:<span class="comment">//addons.g-fox.cn/ntab.gif?c=ntab&amp;t=timing&amp;a=1-o-idb&amp;d=73&amp;f=&amp;r=0.8194234211953002&amp;cid=firefox.com.cn</span></span><br><span class="line">                   <span class="params">&lt;&lt; <span class="number">200</span> OK <span class="number">800</span>b</span></span><br><span class="line"><span class="params"><span class="number">180.165</span><span class="number">.231</span><span class="number">.56</span>:<span class="number">57426</span>: GET http://addons.g-fox.cn/ntab.gif?c=ntab<span class="variable">&amp;t</span>=timing<span class="variable">&amp;a</span>=<span class="number">1</span>-o-cursor<span class="variable">&amp;d</span>=<span class="number">80</span><span class="variable">&amp;f</span>=<span class="variable">&amp;r</span>=<span class="number">0.9766453266846722</span><span class="variable">&amp;cid</span>=firefox.com.cn</span></span><br><span class="line"><span class="params">                   &lt;&lt; <span class="number">200</span> OK <span class="number">800</span>b</span></span><br></pre></td></tr></table></figure></p><h4 id="celery镜像"><a href="#celery镜像" class="headerlink" title="celery镜像"></a>celery镜像</h4><p>环境依赖与proxy镜像的相同，只是运行的启动命令不同；<br>因为这里的数据解析任务我是分为三个队列去执行，这样异步执行可以减少数据处理的时间，相互独立，失败的任务不会影响到其他的任务<br>1.第一个队列create里的任务只是简单的将mitmproxy传递过来的原始pickle后的请求以及响应的对象暂存到redis中，并设置过期时间，然后异步调用analysis队列<br>2.第二个队列analysis里的任务是解析pickle前的request对象和response对象，获取需要的内容，再异步调用save队列<br>3.第三个队列save主要是将解析后的数据更新到mysql中，以供页面回显。</p><p>celery Dockerfile内容如下：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.7</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> requirements.txt /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> pip install -r /tmp/requirements.txt</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> mkdir /code</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . /code</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> docker-entrypoint.sh docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> chmod +x docker-entrypoint.sh</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get install libfontconfig</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> C_QUEUE to_create</span><br><span class="line"><span class="keyword">ENV</span> A_QUEUE to_analysis</span><br><span class="line"><span class="keyword">ENV</span> S_QUEUE to_save</span><br><span class="line"><span class="keyword">ENV</span> QUEUE to_create</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /code/docker-entrypoint.sh</span></span><br></pre></td></tr></table></figure><p>docker-entrypoint.sh执行文件内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$QUEUE</span>"</span> = <span class="string">"<span class="variable">$C_QUEUE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">celery -A handle_data.celery_app worker -l info -Q to_create --uid 13</span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$QUEUE</span>"</span> = <span class="string">"<span class="variable">$A_QUEUE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">celery -A handle_data.celery_app worker -l info -Q to_analysis --uid 13</span><br><span class="line"><span class="keyword">elif</span> [ <span class="string">"<span class="variable">$QUEUE</span>"</span> = <span class="string">"<span class="variable">$S_QUEUE</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">celery -A handle_data.celery_app worker -l info -Q to_save --uid 13</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></p><p>dockerfile中的 ENV 指定环境变量,通过.sh文件判断启动命令里的参数，to_create,to_analysis,to_save 三个队列，指定到不同的消息队列</p><p>启动命令是<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name to_create --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_create -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --name to_analysis --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_analysis -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --name to_save --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_save -d [镜像名称]</span><br></pre></td></tr></table></figure></p><p>–name 启动容器名称</p><p>–link 是关联redis容器，作为数据缓存</p><p>-e 参数后面 指定 QUEUE 为 to_create 队列</p><p>-d 守护进程运行</p><p>启动三个容器，进行数据解析和存库</p><h3 id="迁移到阿里云"><a href="#迁移到阿里云" class="headerlink" title="迁移到阿里云"></a>迁移到阿里云</h3><p>由于客户量增多，需要将服务从我们的服务器扩展到阿里云上, 由于解析后的数据需要放到自己本地的数据库里；</p><p>1.在RabbitMQ上新建一个vhost,存放阿里云代理扔出的任务消息,此处是 newproxy-yuanqu01；</p><p>RabbitMQ是运行阿里云上的另一台服务器，地址为 47.102.218.137:5672<br><img src="Docker中运行mitiproxy-celery/rabbitMQ.png" alt></p><p>2.先运行proxy代理，关联到docker redis 容器<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">run</span> <span class="selector-tag">--name</span> <span class="selector-tag">yct_proxy</span> <span class="selector-tag">--link</span> <span class="selector-tag">yct_redis</span><span class="selector-pseudo">:aliyun_redis</span> <span class="selector-tag">-p</span> 8888<span class="selector-pseudo">:8080</span> <span class="selector-tag">-d</span> <span class="selector-attr">[镜像名称]</span></span><br></pre></td></tr></table></figure></p><p>3.运行celery worker，读取到rabbitMQ中的任务消息去执行,进行数据截取，解析<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name to_create --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_create -d [镜像名称]</span><br><span class="line">docker <span class="builtin-name">run</span> --name to_analysis --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_analysis -d [镜像名称]</span><br></pre></td></tr></table></figure></p><p>4.由于解析后的数据是要存到我们自己的服务器数据库中，所以就要将数据存储的服务部署到自己的服务器上<br>使用同样的yct_worker镜像，连接到阿里云的RabbitMQ，订阅to_save消息队列里的内容，将数据存储到正式环境数据库中<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="builtin-name">run</span> --name to_save --link yct_redis:aliyun_redis -e <span class="attribute">QUEUE</span>=to_save -d [镜像名称]</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> celery </tag>
            
            <tag> mitmproxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中的环境参数(个人使用)</title>
      <link href="/2019/04/20/workfile/"/>
      <url>/2019/04/20/workfile/</url>
      
        <content type="html"><![CDATA[<p><strong><em>服务器</em></strong></p><hr><p>ssh <a href="mailto:python@192.168.1.150" target="_blank" rel="noopener">python@192.168.1.150</a> ,     JYcxys@3030</p><p><strong><em>mysql地址</em></strong></p><hr><p>192.168.1.170:3306  连接串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mysql+pymysql://cic_admin:TaBoq,,1234@192.168.1.170:3306/cicjust_splinter?charset=utf8&amp;autocommit=true"</span></span><br></pre></td></tr></table></figure><p>192.168.10.11:3306 连接串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"mysql+pymysql://cic_admin:159357a@&#123;&#125;:&#123;&#125;/cic_splinter?charset=utf8&amp;autocommit=true"</span></span><br></pre></td></tr></table></figure><p>Mysql 远程连接</p><p>mysql -u 用户名 -p密码 -h IP地址 -P 端口号 -D 数据库名字 </p><hr><p><strong>celery配置</strong></p><hr><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_HOST = <span class="string">'192.168.1.152'</span></span><br><span class="line">RABBITMQ_PORT = <span class="number">5672</span></span><br><span class="line"></span><br><span class="line">RABBITMQ_USER = <span class="string">'rabbitmq'</span></span><br><span class="line">RABBITMQ_PWD = <span class="string">'JYcxys@3030'</span></span><br><span class="line"></span><br><span class="line">REDIS_HOST = <span class="string">"192.168.1.152"</span></span><br><span class="line">REDIS_PORT = <span class="number">16379</span></span><br><span class="line"></span><br><span class="line">CELERY_BROKER_URL = <span class="string">'amqp://&#123;0&#125;:&#123;1&#125;@&#123;2&#125;:&#123;3&#125;/myvhost'</span>\</span><br><span class="line">    .format(RABBITMQ_USER,RABBITMQ_PWD,RABBITMQ_HOST,RABBITMQ_PORT)</span><br><span class="line"></span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">'redis://&#123;0&#125;:&#123;1&#125;/15'</span>.format(REDIS_HOST,REDIS_PORT)</span><br></pre></td></tr></table></figure><p><strong><em>celery命令</em></strong></p><p>1.守护进程启动方式(start/stop/restart)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">celery multi start export_for_in -A celery_tasks.celery_app -l info --logfile=./celerylog.log</span><br></pre></td></tr></table></figure><p>2.开启flower后台监控</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">celery.exe flower --broker=amqp://guest:guest@localhost:5672/test</span><br><span class="line">celery.exe flower -broker=amqp://cic_admin:JYcxys@3030@192.168.1.152:5672/yct</span><br></pre></td></tr></table></figure><p><strong><em>rabbitmq的安装与配置</em></strong></p><p><em>Windows安装rabbitmq</em></p><p><strong><em>docker命令</em></strong></p><hr><ol><li><p>启动chrome镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -d --name chrome_for_yzf -p 5902:5900 -p 4442:4444 selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure></li><li><p>下载镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure><p>说明：standalone-chrome-debug 镜像是带有vnc server </p></li><li><p>运行容器(–name后为容器的名称,-d 守护进程运行,-p 由容器露出的8080端口,映射到宿主机的8081端口)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name your_app_name -p 8081:8080 -d selenium/standalone-chrome-debug</span><br></pre></td></tr></table></figure></li><li><p>使用docker MySQL</p><ol><li><p>拉取mysql镜像 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li><li><p>运行MySQL容器 dockers(MYSQL_ROOT_PASSWORD=后为数据库定义密码用户名为root)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql_service -e MYSQL_ROOT_PASSWORD=your_pwd -d daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li><li><p>使用其他的docker容器连接docker的MySQL服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name some_app --link your_mysql_name:mysql -p 8080:8080 -d daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li><li><p>将MySQL容器内的数据持久化到宿主机上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name mysql --privileged=true -v /home/docker_mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=cicjust_proxy -d daocloud.io/library/mysql</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu下安装python3</title>
      <link href="/2019/03/01/ubuntu%E4%B8%8Bpython3%E7%9A%84%E5%AE%89%E8%A3%85/"/>
      <url>/2019/03/01/ubuntu%E4%B8%8Bpython3%E7%9A%84%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ubuntu系统自带python2.7，不同的版本的ubuntu所带的python3的版本也有所不同，我现在使用的这台是python3.5;由于需要的服务只支持python3.6以上版本，所以本文以安装python3.7为例</p><h4 id="服务器运行环境："><a href="#服务器运行环境：" class="headerlink" title="服务器运行环境："></a>服务器运行环境：</h4><pre><code>ubuntu18.04</code></pre><h4 id="安装方式简介"><a href="#安装方式简介" class="headerlink" title="安装方式简介:"></a>安装方式简介:</h4><pre><code>不影响已有的python其他版本环境增量式安装完全隔离的沙箱环境</code></pre><h3 id="基本环境-便于后面的编译成功"><a href="#基本环境-便于后面的编译成功" class="headerlink" title="基本环境(便于后面的编译成功)"></a>基本环境(便于后面的编译成功)</h3><p>中间可能有多余空格，去除下再运行，一般都能安装成功，如果不能可以先更新下sudo apt-get update</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install zlib1g-<span class="built_in">dev</span> libbz2-<span class="built_in">dev</span> libssl-<span class="built_in">dev</span> libncurses5-<span class="built_in">dev</span> libsqlite3-<span class="built_in">dev</span> </span><br><span class="line">libreadline-<span class="built_in">dev</span> tk-<span class="built_in">dev</span> libgdbm-<span class="built_in">dev</span> libdb-<span class="built_in">dev</span> libpcap-<span class="built_in">dev</span> xz-utils libexpat1-<span class="built_in">dev</span> </span><br><span class="line">liblzma-<span class="built_in">dev</span> libffi-<span class="built_in">dev</span> libc6-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>在python官网下载指定平台下的python3.7.1的环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.python.org/ftp/python/3.7.1/Python-3.7.1.tgz</span><br></pre></td></tr></table></figure><p>下载完成后，所在目录下会有 Python-3.7.1.tgz 的文件</p><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><p>进行解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvzf Python-3.7.1.tgz</span><br></pre></td></tr></table></figure><p>所在目录下会有 Python-3.7.1 的文件夹</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>进入文件夹Python-3.7.1,进行配置</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> Python-3.7.1</span><br><span class="line"><span class="string">./configure</span> <span class="params">--with-ssl</span> <span class="params">--prefix=/usr/local/python3</span></span><br></pre></td></tr></table></figure><p>编译、安装</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span></span><br><span class="line"><span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><blockquote><p>执行后可能会报错，请参考<a href="https://blog.csdn.net/jpch89/article/details/81813267" target="_blank" rel="noopener">https://blog.csdn.net/jpch89/article/details/81813267</a></p></blockquote><h3 id="删除软链"><a href="#删除软链" class="headerlink" title="删除软链"></a>删除软链</h3><p>先执行查看版本，如果有则证明软连接已经存在，先将其删除再重新建立</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="selector-tag">python3</span> <span class="selector-tag">-V</span></span><br><span class="line"><span class="selector-tag">Python</span> 3<span class="selector-class">.5</span><span class="selector-class">.2</span></span><br></pre></td></tr></table></figure><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># pip3 -V</span></span><br><span class="line">The program <span class="string">'pip3'</span> <span class="keyword">is</span> currently <span class="keyword">not</span> installed. You can install <span class="literal">it</span> <span class="keyword">by</span> typing:apt install python3-pip</span><br></pre></td></tr></table></figure><p>可见我的机器上的默认的python3的版本为3.5，pip3没有安装</p><p>删除软链</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># rm -rf /usr/bin/python3</span></span><br><span class="line"><span class="meta"># rm -rf /usr/bin/pip3</span></span><br></pre></td></tr></table></figure><h3 id="建立新的指向python3-7的软链"><a href="#建立新的指向python3-7的软链" class="headerlink" title="建立新的指向python3.7的软链"></a>建立新的指向python3.7的软链</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加python3的软链接</span></span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/python3/</span>bin<span class="regexp">/python3.7 /u</span>sr<span class="regexp">/bin/</span>python3</span><br><span class="line"><span class="comment">#添加 pip3 的软链接</span></span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/python3/</span>bin<span class="regexp">/pip3.7 /u</span>sr<span class="regexp">/bin/</span>pip3</span><br></pre></td></tr></table></figure><h3 id="查看版本"><a href="#查看版本" class="headerlink" title="查看版本"></a>查看版本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># python3 -V</span><br><span class="line">Python 3.7.1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># pip3 -V</span><br><span class="line">pip 10.0.1 from /usr/local/python3/lib/python3.7/site-packages/pip (python 3.7)</span><br></pre></td></tr></table></figure><p>至此安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小记--阿里云pip配置虚拟环境报错</title>
      <link href="/2019/03/01/%E5%B0%8F%E8%AE%B0--%E9%98%BF%E9%87%8C%E4%BA%91pip%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99/"/>
      <url>/2019/03/01/%E5%B0%8F%E8%AE%B0--%E9%98%BF%E9%87%8C%E4%BA%91pip%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>今天在阿里云上使用pip3安装虚拟环境的时候，出现了一个错误locale.Error: unsupported locale setting</p><p>不支持语言环境，报错如下：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@iZuf6eh47kp5ew16h2mywqZ:~<span class="comment"># sudo pip3 install virtualenv</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"/usr/bin/pip3"</span>, line <span class="number">11</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    sys.<span class="keyword">exit</span>(main())</span><br><span class="line">  File <span class="string">"/usr/lib/python3/dist-packages/pip/__init__.py"</span>, line <span class="number">215</span>, <span class="keyword">in</span> main</span><br><span class="line">    locale.setlocale(locale.LC_ALL, <span class="string">''</span>)</span><br><span class="line">  File <span class="string">"/usr/lib/python3.5/locale.py"</span>, line <span class="number">594</span>, <span class="keyword">in</span> setlocale</span><br><span class="line">    return _setlocale(category, locale)</span><br><span class="line">locale.Error: unsupported locale setting</span><br></pre></td></tr></table></figure><p>解决办法很简单，设置语言就好了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export LC_ALL=&quot;en_US.UTF-8&quot;</span><br><span class="line">export LC_CTYPE=&quot;en_US.UTF-8&quot;</span><br></pre></td></tr></table></figure><p>执行上面这两句就OK了，后面就可以继续pip安装了。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python之上下文管理器</title>
      <link href="/2018/05/29/python%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/"/>
      <url>/2018/05/29/python%E4%B9%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>每一个用python的人都知道用with open来操作文本资源，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><h4 id="一、为什么使用with来操作文本文件？"><a href="#一、为什么使用with来操作文本文件？" class="headerlink" title="一、为什么使用with来操作文本文件？"></a>一、为什么使用with来操作文本文件？</h4><p>对于系统资源如文件、数据库连接、socket而言，应用程序在打开这些资源并且执行完业务逻辑操作之后，<br>必须要做的一件事就是关闭（断开）该资源。</p><p>例如python打开一个文本文件并写入一段内容之后，如果频繁打开写入文件不做关闭操作，就会出现”too many open files”的错误，<br>因为系统允许打开同一个文件的次数是有限的。</p><p>同样，对于数据库，如果连接次数过多而没有及时关闭的话，就可能会出现”Can not<br>connect to MySQL server Too many connections”,因为数据库的连接是非常珍贵的资源，不可能无限制的创建连接。</p><p>正确的操作一个资源文件，如下：</p><h5 id="普通版"><a href="#普通版" class="headerlink" title="普通版"></a>普通版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    f = open(filename,<span class="string">'w'</span>)</span><br><span class="line">    f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><p>这种方式比较繁琐，每次在操作完文件之后还要关闭，如果在写入过程中出现错误，<br>就会直接终止整段程序，所以要加入try异常捕获机制。</p><h5 id="捕获异常版"><a href="#捕获异常版" class="headerlink" title="捕获异常版"></a>捕获异常版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f = open(filename,<span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        print(<span class="string">'打开文件 &#123;&#125; 出现异常'</span>.format(filename))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        f.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><p>这种方式就会避免程序终止，在finally最后会对文件进行close关闭操作。</p><h5 id="with简洁版"><a href="#with简洁版" class="headerlink" title="with简洁版"></a>with简洁版</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_files</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'w'</span>) <span class="keyword">as</span> f :</span><br><span class="line">        f.write(<span class="string">'脑筋急转弯：一加一等于几'</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    open_files(<span class="string">'脑筋急转弯大全.txt'</span>)</span><br></pre></td></tr></table></figure><p>当离开 with 缩紧的代码块时，会自动调用 f.close() 关闭，由此可知 with 就相当于前一个版本的 try/finally。<br>此处with的实现原理就是上下文管理器（Context Manager）。</p><h4 id="二、什么是上下文管理器（Context-Manager）"><a href="#二、什么是上下文管理器（Context-Manager）" class="headerlink" title="二、什么是上下文管理器（Context Manager）"></a>二、什么是上下文管理器（Context Manager）</h4><p>任何实现了<strong>enter</strong>() 和<strong>exit</strong>() 方法的对象都可称之为上下文管理器，上下文管理器对象可以使用 with 关键字。显然，文件（file）对象也实现了上下文管理器。</p><p>那么文件对象是如何实现这两个方法的呢？我们可以模拟实现一个自己的文件类，让该类实现<strong>enter</strong>() 和<strong>exit</strong>() 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename, mode)</span>:</span></span><br><span class="line">        self.filename = filename</span><br><span class="line">        self.mode = mode</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"entering"</span>)</span><br><span class="line">        self.f = open(self.filename, self.mode)</span><br><span class="line">        <span class="keyword">return</span> self.f</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">        print(<span class="string">"exiting"</span>)</span><br><span class="line">        self.f.close()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用自定义的File类来执行一下</span></span><br><span class="line">    <span class="keyword">with</span> File(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">         f.write(<span class="string">"test one two tree four"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure><p>其中<strong>enter</strong>() 方法返回资源对象，这里就是你将要打开的那个文件对象f，而<strong>exit</strong>()方法可以处理一些清除工作。<br>因为 File类 实现了上下文管理器，现在就可以使用 with 语句来操作资源文件。</p><h4 id="三、-contextmanager-装饰器实现上下文管理器"><a href="#三、-contextmanager-装饰器实现上下文管理器" class="headerlink" title="三、@contextmanager 装饰器实现上下文管理器"></a>三、@contextmanager 装饰器实现上下文管理器</h4><p>python 还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。<br>通过 yield 将函数分割成两部分，yield 之前的语句在<strong>enter</strong> 方法中执行，yield 之后的语句在 <strong>exit</strong> 方法中执行。紧跟在 yield 后面的值是函数的返回值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_open</span><span class="params">(path,mode)</span>:</span></span><br><span class="line">    f = open(path,mode)    <span class="comment">## __enter__</span></span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    f.close()        <span class="comment">## __exit__</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 使用自定义的File类来执行一下</span></span><br><span class="line">    <span class="keyword">with</span> my_open(<span class="string">"test.txt"</span>,<span class="string">"w"</span>) <span class="keyword">as</span> f:</span><br><span class="line">         f.write(<span class="string">"test one two tree four"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>python 提供了 with 语法用于简化资源操作的后续清除操作，是 try/finally 的替代方法，实现原理建立在上下文管理器之上。<br>此外，python 还提供的 contextmanager 装饰器，更进一步简化上下管理器的实现方式。</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
